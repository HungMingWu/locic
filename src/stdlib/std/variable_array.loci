template <typename T, typename Array: array<T>>
class array_range(const Array& array, size_t start, size_t end) {
	static default(const Array& array){
		return @(array, 0, array.size());
	}
	
	bool empty() const {
		return @start == @end;
	}
	
	void popFront() {
		assert(!self.empty());
		@start++;
	}
	
	T ref front() const {
		assert(!self.empty());
		return ref @array[@start];
	}
	
	void popBack() {
		assert(!self.empty());
		@end--;
	}
	
	T ref back() const {
		assert(!empty());
		return ref @array[@end - 1];
	}
	
	bool invariant() const {
		return @start <= @end && (!self.empty() => @end > 0);
	}
	
}

template <typename T>
using variable_array_range = array_range<T, variable_array<T>>;

template <typename T>
class variable_array(size_t size, size_t capacity, T* data) if (T.is_concrete()) {
	static default() {
		@(0, 0, null);
	}
	
	static literal_array(const forward_range<T>& range) {
		auto array = variable_array<T>();
		for(value in range){
			array.push_back(move(value));
		}
		return array;
	}
	
	void reserve(size_t size) {
		if(size <= @capacity) return;
		T* newData = reinterpret_cast<T*>(calloc(size, sizeof(T)));
		for(i in 0 .. @size){
			newData[i] := move @data[i];
		}
		@data = newData;
		@capacity = size;
	}
	
	size_t capacity() const {
		return @capacity;
	}
	
	void resize(size_t size) {
		reserve(size);
		for(i in size .. @size){
			@data[i] := void;
		}
		@size = size;
	}
	
	size_t size() const {
		return @size;
	}
	
	T ref indexAt(size_t index) const {
		assert(index < @size);
		return ref @data[index];
	}

	variable_array_range<T> range() const {
		return variable_array_range<T>(@data, 0, @size);
	}
	
	if(T.implements(copyable<T>)){
		variable_array<T> copy() const {
			auto array = variable_array<T>();
			array.resize(@size);
			for(i in 0 .. @size){
				array[i] := self[i].copy();
			}
			return array;
		}
	}
}


