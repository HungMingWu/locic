/*template <typename T>
__primitive ptr{
	static Null();
	
	ptr<T> implicitCopy();
	
	T& derefGet() const;
	
	void derefSet(T value);
	
	T derefMove();
	
	T& indexGet(size_t index) const;
	
	void indexSet(size_t index, T value);
	
	T indexMove(size_t index);
	
	T * indexPtr(size_t index);
	
	template <any S>
	ptr<S> castPolymorphic();
};

template <any T>
class uptr(T * p){
	static Null();
	
	static Default(T * p);
	
	T& derefGet() const{
		return *p;
	}
};

template <abstract T>
class dptr(T& p0, T& p1){
	
}

template <any T>
__primitive ref{
	
};

template <typename T>
class A(T * p){
	
};

template <any T>
interface array{
	T& indexGet(size_t index) const;
	const T& indexGet(size_t index) const <const T>;
	void indexSet(size_t index, T value);
};

void fn(){
	ref<variable_array<Class>> v = ...;
	const ref<const array<Interface>> a = v;
	
	T ** p = ...;
	Interface * const * const i = p;
	
	uptr<T> p = ...;
	uptr<? : Interface> i = p;
	
	uptr<uptr<T>> p = ...;
	const uptr<const uptr<Interface>> i = p;
	
	dptr<dptr<T>> p = ...;
	const dptr<const dptr<Interface>> i = p;
	
	vararray<Interface> v = ...;
	v[2] = 
	
	ptr<Interface> p = ...;
	ptrarray<Interface> v = ...;
	array<Interface *> v = ...;
	
	uptr<Interface> p = ...;
	
	uptr<Class> q = ...;
	const uptr<Interface> r = q;
	
	final Type value = ...;
	typeof(&value) == Type * const;
	Type * ptr = ...;
	
	std::vector<int> array = ...;
	std::vector<int> * const arrayPtr = &array;
	
	const std::vector<int> array2 = array;
	const std::vector<int> * array2Ptr = &array2;
	*array2Ptr = ;
	
	int i = 0;
	int * j = &i;
	int ** k = &j;
	const int ** l = k;
	
	const int * m = ...;
	*l = m;
	j
	
	int i = 0;
	int * j = &i;
	int ** k = &j;
	
	int i = 0;
	const int * 
	const int j = i;
	const int * k = &j;
	*k = 
	
	const (int **)
	
	const (mutable(int *) *) f = 
	
	int ** const f;
	
	//-----------------
	int * i = ...;
	int * const j = ...;
	
	int * const * i = ...;
	const int * const * j = i;
	
	//-----------------
	Class * c = ...;
	Interface * const i = c;
	
	ptr<Class> c = ...;
	const ptr<Interface> i = c;
	
	Class& c = ...;
	Interface& i = c;
	
	ref<Class> c = ...;
	ref<Interface> i = c;
	
	//-----------------
	int ** i = ...;
	int ** const j = i;
	Interface * const * const k = j;
	Interface * const l = j;
	
	ptr<ptr<int>> i = ...;
	const ptr<ptr<int>> j = i;
	const ptr<const ptr<Interface>> k = j;
	const ptr<Interface> l = j;
}*/

__primitive null_t{ };

__primitive bool{
	bool implicitCopy();
	
	bool not();
};

__primitive char{
	char implicitCopy();
	
	int compare(char v);
	
	bool isZero();
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

__primitive short{
	short implicitCopy();
	
	short abs();

	short add(short v);
	short subtract(short v);
	short multiply(short v);
	short divide(short v);
	short modulo(short v);
	
	int compare(short v);
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

__primitive int{
	static Default();	
	
	int implicitCopy();
	
	int abs();

	int add(int v);
	int subtract(int v);
	int multiply(int v);
	int divide(int v);
	int modulo(int v);
	
	int compare(int v);
	bool isZero();
	bool isPositive();
	bool isNegative();
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

__primitive long{
	long implicitCopy();
	
	long abs();

	long add(long v);
	long subtract(long v);
	long multiply(long v);
	long divide(long v);
	long modulo(long v);
	
	int compare(long v);
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

__primitive float{
	float implicitCopy();

	//float add(float v);
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

__primitive double{
	double implicitCopy();
	
	//double add(double v);
	
	double multiply(double v);
	
	/*char toChar();
	short toShort();
	int toInt();
	long toLong();
	float toFloat();
	double toDouble();*/
};

/*template <typename T, typename Ret, typename[] Param>
class interface_method(T* objectPtr, void* vtable, uint32_t value) {
	static Default(T* objectPtr, void* vtable, uint32_t value){
		return @(objectPtr, vtable, value);
	}
	
	interface_method<T, Ret, Param> implicitCopy() const {
		return interface_method(@objectPtr, @vtable, @value);
	}
	
	Ret opCall(Param args[]) const {
		auto vtableArray = static_array<void *>(@vtable);
		auto f = function_ptr<Ret, {T*} + Param>(
		f(@objectPtr, args);
	}
};*/


