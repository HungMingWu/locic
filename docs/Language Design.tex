\documentclass[12pt,twoside,notitlepage]{report}

\title{Loci Programming Language}
\author{Stephen Cross}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

%%%%%%%%%%%%% TITLE PAGE %%%%%%%%%%%%%
\pagestyle{empty}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Loci Programming Language} \\
\vspace*{5mm}
Stephen Cross \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%% TABLE OF CONTENTS %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\tableofcontents

\listoffigures

\cleardoublepage

%%%%%%%%%%%%% CONTENT %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

\paragraph{}
The C programming language is a widely used programming language and compilers are available for almost all architectures. Furthermore, many programming languages provide the means to call into/out-of C, facilitating interoperation of different programming languages with C as a `bridge'. While technically useful, the C programming language is often perceived as lacking sufficiently powerful abstractions to construct large and complex systems. For this reason, languages such as C++, Objective C and D were invented to provide abstractions on top of the language.

\paragraph{}
Unfortunately, these languages have significant problems. For example, C++ and D place undue attention to compile-time funtionality that serves to complicate the source code. Interestingly, Objective-C shifts the vast majority of the burden to run-time, and hence uses weak typing. Preference of programming languages is certainly based on the opinion of individual programmers, however languages also face general criticism. In particular, C++ attracts criticism due to its large set of features and rules that ultimately combine to produce complex semantics. Equally, however, programmers support the combination of powerful features as found in a multi-paradigm language such as C++.

\paragraph{}
The design of languages that are both simple and powerful is difficult, and popular existing programming languages represent a variety of reasonable solutions. A number of newer languages have emerged that operate at a `higher level' than languages such as C and C++, of which examples are Java and C\#. Typically, these languages use primitives and pointers as fundamental types, deploy some form of garbage collection, use classes as their fundamental data structures and provide the means to construct inheritance hierarchies. There is a disputed performance cost to using these languages over lower level languages, which is generally found to be small and hence arguably insignificant.

\paragraph{}
However, these languages also suffer significant problems: there are no deterministic destruction routines (which must be provided by the programmer through constructs such as try...finally), the languages have extensive dependencies on the large and complex environment that supports them and they lack direct access to lower level routines typically available in C. Furthermore, despite aims to remain simple, many of these languages have become increasingly complex as it is discovered the initial design was insufficiently powerful. Special cases (e.g. Java's + operator for strings) further serve to complicate the languages.

\section{Aims}

\paragraph{}
This document therefore describes and rationalises the design of the Loci programming language, which aims to provide strong compatibility with C, while adding useful efficient high level abstractions, and without the complexities that arise in C++.

\paragraph{}
Loci should satisfy the following (quite vague) goals:

\begin{itemize}
\item Modular - The language must help to produce programs in which the basic problem is split into distinct components, which can be easily re-combined to solve other problems.
\item Portable - The language should be independent of any specific machine architecture or operating system, such that programs can be ported easily.
\item Compatible - The language must be compatible with existing languages/standards so that it can make use of existing services.
\item Simple - The language must remove all unnecessary complexity and maximize developer efficiency so that time can be best spent solving the problem at hand. It is important to reduce the learning curve to remove any barriers preventing new developers from embracing the language.
\item Clean - The language must help to produce clean and consistent applications which can be easily read and understood. It is important that when one developer sees code written by another developer it is easy for them to understand it, in order to aid collaboration.
\item Small - The language must produce resulting code that is small and free of dependencies except those specified in the program and understood to the developer, such that distribution is simple and fast.
\item Fast - The language must provide good performance, to maximise its utility.
\end{itemize}

\section{Name}

\paragraph{}
While it has been suggested that Loci could stand for `Loci: objects, classes and interfaces', this is not the intended understanding because the language is much more than just being object orientated\footnote{Like C++, Loci is a multi-paradigm language.}. Instead, the name reflects the following definitions of its singular form:

\begin{quotation}
\emph{locus} - the set of all points or lines that satisfy or are determined by specific conditions
\end{quotation}
\begin{quotation}
\emph{locus} - A place or locality, especially a centre of activity
\end{quotation}

\section{Specific Goals}

\paragraph{}
Establishing this basis for Loci, it is possible to elaborate more specific goals for the language:

\begin{itemize}
\item \textbf{Provide stable interfaces between modules.} A change in one module should not require a module that depends on it to be re-compiled, unless there are changes that break the API. In particular, classes in libraries can change their internal structure (i.e. their member variables) without requiring re-compilation of clients of the library.
\item \textbf{Follow a standard binary interface for each platform.} Modules compiled by different compilers must work together. Loci creates standard C functions with fixed naming rules and calling conventions.
\item \textbf{Fast compile times.} This is vital to maximise productivity. Loci files are effectively isolated from each other, such that they can be tokenized and parsed in parallel, and then the resulting structures can be used to resolve and verify dependencies. Effectively parallelising builds for other languages is often significantly more complex.
\item \textbf{Minimal syntactic complexity.} For example, header guards are required in C to prevent a header from being included twice. In Loci all files are equal and are only analyzed once, so there is no need to add any sort of guards. Furthermore the Loci compiler uses multiple passes so type declarations/definitions do not have to appear before their use.
\item \textbf{Minimal semantic complexity.} Loci avoids language features (or combinations of language features) that affect the readability and predictability of code. For example, Loci does not support function or method overloading, since these can easily increase the complexity of the language with little to no added benefit.
\item \textbf{Provide a powerful polymorphism mechanism.} Loci provides interfaces, that are effectively equivalent to C++ pure virtual classes with a virtual destructor, or Java interfaces. Loci uses structural typing, so casts are allowed from classes to interfaces if the class provides all the methods required by the interface.
\end{itemize}

\cleardoublepage

\chapter{Design}

\paragraph{}
One of the defining aspects of Loci is that everything is an object and all objects are subject to the same rules (unlike Java, in which the string + operator is a special case). Loci places an emphasis on interfaces, to such an extent that they are the only way polymorphism can be achieved, and extends inheritance only contributes to code reuse. As a result of this, Loci is able to easily support multiple inheritance, however the units being inherited from are called ‘partial classes’. The relationship of interfaces, classes and partial classes is not complicated, however it needs to be (and will be) demonstrated in code.

\paragraph{}
Further defining aspects of Loci include the elimination of global and static variables, no downcasting, no null, no switch statements, no break or continue, a for-each loop, clear naming rules, easy to read import statements and no static methods. Each of the 'features' left out are considered at least unnecessary and potentially harmful. However, Loci shares many things in common with other languages: namespaces, operator overloading, generics (unlike Java these do not suffer type erasure) and an immutable string type (like Java strings, except implemented as ropes). Furthermore, the language adds constructs and functionality that represent a more effective replacement for some of these features.

\paragraph{}
Loci is focused on the goal of providing one effective method to solve problems, rather than providing multiple (and potentially poor) solutions. As a result, the design of the language is focused on removing unnecessary features and maintaining conceptual consistency. The language can help the developer to avoid common pitfalls and eliminate the additional complexity that arises with the existence of null, global data, manual memory allocation, checked exceptions etc.. Furthermore Loci enforces some important design decisions, to alleviate groups of programmers from having to define code design specifications and provide useful assumptions to developers reading code. For example, capitalised names must be type names or type constructors, whereas names that start with a lower case letter must be variables or method/function names. The only exceptions to this rule are the built-in types, which are named starting with lowercase (e.g. int), since this is familiar to programmers from Java and C++.

\paragraph{}
The conceptual model of the language seeks to reject the notion that programming languages must be complicated, or that any particular paradigm should be used exclusively, using ideas from a variety of existing languages and integrating them effectively. The language aims to target general purpose software on various platforms, respecting the need for languages such as C++ at lower levels, or scripting languages at higher levels.

\section{Design Decisions}

\subsection{Stack Allocated vs Heap Allocated}

\paragraph{Stack Allocated}
\begin{itemize}
\item Cheaper allocation/deallocation
\item Extra work to identify locations of variable length data on the stack
\end{itemize}

\paragraph{Heap Allocated Data}
\begin{itemize}
\item Simpler to implement
\item Cheaper moving
\end{itemize}

\section{Type Syntax}

\paragraph{}
Loci strictly follows the following structure for all typed variables declarations:

\begin{verbatim}
[TYPE] [NAME]
\end{verbatim}

\paragraph{}
This differs significantly from C, in which types and names can overlap in confusing ways, such as in function pointer types:

\begin{verbatim}
void (*f)(); // C
*()() f; // Loci

int (*f)(); // C
*(int)() f; // Loci

int (*f)(int, int); // C
*(int)(int, int) f; // Loci
\end{verbatim}

\paragraph{}
Loci also provides `alias' as a clearer alternative to `typedef':

\begin{verbatim}
typedef OldType NewType; // C
alias NewType = OldType; // Loci
\end{verbatim}

\section{References}

\paragraph{}
Along with pointers, Loci uses references as equivalent to a pointer type, except that they must not be null. For example:

\small{
\begin{verbatim}
void function(int * pointer){
    // Illegal - no implicit cast allowed.
    int& ref0 = pointer;
    
    // Correct - triggers exception if
    // pointer == null.
    int& ref1 = cast<int&>(pointer);
    
    int data = 0;
    
    // Valid - typeof(&data) == typedata(int&).
    // (and references can be changed in Loci)
    ref1 = &data;
    
    // Valid - implicit cast from int&
    // to int* is provided.
    pointer = ref1;
}
\end{verbatim}
}

\paragraph{}
This is somewhat different to C++ references, which cannot be changed after they have been assigned, and which operate at the level of value types. However, this can lead to confusing behaviour, as in the following C++ code example:

\small{
\begin{verbatim}
// This is C++ code!

int f1(int r){
    r = 1;
    return r;
}

int f2(int& r){
    r = 1;
    return r;
}

int g(int * r){
    *r = 1;
    return *r;
}

void function(){
    int a = 0, b = 0;
    
    // (a = 0, b = 0).
    
    b = f1(a);
    
    // (a = 0, b = 1) - Ok, this is expected.
    
    b = f2(a);
    
    // (a = 1, b = 1) - Surprise modification to a!
    
    a = 0;
    b = 0;
    
    b = g(&a);
    // Less surprising that f modifies a.
}
\end{verbatim}
}

\paragraph{}
The behaviour of `f2' is unintuitive because the parameter passed to it is received by its address (since references are implemented as pointers), without the address-of operator being applied to the parameter. Furthermore, `f1' and `f2' differ by a single character, but their behaviour is significantly different; the code of `g' makes it clear that the parameter is being handled by its address.

\paragraph{}
There is, however, a good argument for allowing such behaviour for efficiency purposes, since copying a large parameter type may be undesirable. Loci therefore supports an implicit cast from an lvalue `T' to `const T\&', as demonstrated in the following code:

\small{
\begin{verbatim}
struct HugeType{
    int i0;
    // etc...
    int i99999;
};

int f(HugeType h){
    return h.i31415;
}

int g(const HugeType& h){
    return h->i31415;
}

void function(){
    HugeType h = HugeType();
    
    // Potentially costly copy.
    printf("%i\n", f(h));
    
    // No copy.
    printf("%i\n", g(h));
}
\end{verbatim}
}

\section{Classes}

\paragraph{}
The ability to create and manipulate objects, which are instances of a class, provides a useful way to encapsulate a set of behaviour around a particular data type, and maintaining the necessary invariants needed by that type. Therefore Loci, like many other languages, includes support for object oriented programming.

\subsection{Definitions}

\paragraph{}
Here's an example of a Loci class definition:

\small{
\begin{verbatim}
class Bucket(bool b, int value){
    bool containsValue(){
        return @b;
    }
    
    void placeValue(int value){
        assert(!@b);
        @value = value;
    }
    
    int getValue(){
        assert(@b);
        return @value;
    }
}
\end{verbatim}
}

\paragraph{}
The organisation is somewhat different to many languages, and member variables are defined within the parentheses after the class name. The methods, constructors and destructors then appear within the braces that follow.

\paragraph{}
Another detail is that instance member variables are referred to using the @ symbol, which provides a clean alternative to the various C++ conventions for naming such variables\footnote{For example: `mValue' or `value\_'.}; such variables are also accessible through the use of the `this' reference:

\small{
\begin{verbatim}
    //...
    bool containsValue(){
        return this->b;
    }
    //...
\end{verbatim}
}

\subsection{Declarations}

\paragraph{}
Perhaps more interesting is the ability to declare classes. Unlike C++ where this is commonly needed, declarations typically won't be needed within a shared codebase, because Loci can find the class definitions and produce their corresponding declarations automatically.

\paragraph{}
Additionally, Loci uses multiple passes so that there is no need to define types or functions before they are used, so there is no need to declare a class which is later defined in the same code base, something that is common in C and C++.

\paragraph{}
However, if a class is to be used across an API boundary\footnote{For example, the class is defined inside a static library, and a program uses the declaration to create instances of the class and call its methods.} then declarations should be used.

\paragraph{}
Here's a declaration of the Bucket class:

\small{
\begin{verbatim}
class Bucket{
    bool containsValue();
    
    void placeValue(int value);
    
    int getValue();
}
\end{verbatim}
}

\paragraph{}
Clearly, the class method implementations have been removed, however the member variables have also been removed. This is because, unlike C++, class declarations in Loci do \emph{not} need to include the types (or names) of the member variables.

\paragraph{}
From a design perspective, this prevents the need to use forward struct declarations (or similar) and heap allocations that are needed in C and C++, and is part of fulfilling Loci's goal to be an excellent language for defining, implementing and using APIs.

\paragraph{}
Therefore clients of a library do not need to be recompiled when a class in the library changes its member variables, since this is private information.

\paragraph{}
The implementation of this feature is described in the next section.

\section{New Operator}

\paragraph{}
Like C++, Loci provides the new operator, although the syntax and semantics are slightly different.

\small{
\begin{verbatim}
class Type(int a){ }

Type f(){
    return Type(5);
}

void function(){
    // Stack and heap allocations, like in C++.
    Type stackAllocated = Type(0);
    Type& heapAllocated = new<raw> Type(0);
    
    // Allocates space on heap, and moves from
    // stack to heap.
    Type& heapMoved = new<raw> f();
    
    // Raw allocations must be deallocated.
    delete heapAllocated;
    delete heapMoved;
}
\end{verbatim}
}

\paragraph{}
In particular:

\begin{enumerate}
\item The new operator can be applied to any R-value (the details of which are described later) of the desired type, and will move that value onto the heap.
\item The new operator returns a reference.
\item The new operator accepts a parameter giving the allocation method (also called the memory management method), which in the case of the example is a raw allocation, as in C++.
\end{enumerate}

\subsection{Memory Management Methods}

\paragraph{}
The above shows `raw' allocations, in which allocation and construction of objects is performed as in C++. However, Loci supports other forms of allocation:

\small{
\begin{verbatim}
void function(){
    // Automatically freed when leaving scope,
    // but only one instance can exist.
    UPtr<Type> uniquePtr = new<unique> Type(0);
    
    // Above is just syntactic sugar for...
    UPtr<Type> uniquePtr1 = UPtr<Type>(new<raw> Type(0));
    
    // Invalid - cannot copy unique pointers.
    UPtr<Type> uniquePtr2 = uniquePtr;
    
    // Allocated via garbage collection.
    Type& gcPtr = new<gc> Type(0);
    
    // Reference counted.
    SPtr<Type> sharedPtr = new<shared> Type(0);
    
    // Can be copied, increasing ref count.
    SPtr<Type> sharedPtr1 = sharedPtr;
    
    // Invalid - there is no default.
    auto defaultPtr = new Type(0);
}
\end{verbatim}
}

\paragraph{}
Clearly, the aim is to minimise the syntax required to instantiate an object on the heap, while maximising the available options for how to manage the memory. Garbage collection is also available, using a conservative collector\footnote{Meaning that it doesn't need to move memory, which would be difficult to do at the level of C.}, and this is generally a good choice for allocating POD\footnote{Plain Old Data} types such as vectors, strings, trees etc.

\paragraph{}
The lack of a default also forces the programmer to think about how objects are to be allocated. C++ chooses to use a raw allocation as the basis of the new operator, however this is possibly the most dangerous choice because exceptions can cause a delete statement to be missed and therefore memory is leaked; the other memory management methods are much safer.

\subsection{Garbage Collection}

\paragraph{}
Finally, Loci will disallow the allocation of an object via garbage collection if it has a destructor. Finalisers could've been used to trigger destructor execution, but they are \emph{not deterministic}, and therefore any actions within the destructor cannot be guaranteed to be executed at a reasonable time\footnote{Unless other methods, such as reference counting, are used, however this defeats the purpose of garbage collection.}.

\paragraph{}
Normally, anyway, types which might be garbage collected should not require a destructor, since most destructors are simply required for managing memory of the type's member variables. Note also that if the member variables have destructors, then the type itself must also have an auto-generated destructor which will call them.

\paragraph{}
However, as with all rules, there may be reasonable exceptions, so a `forcegc' option is provided:

\small{
\begin{verbatim}
class Type(int v){
    ~Type(){
        printf("Destructor.\n");
    }
};

void function(){
    // Fails to compile - 'Type' has destructor.
    Type& gcPtr = new<gc> Type(0);
    
    // Succeeds - but probably isn't wise.
    Type& gcPtr1 = new<forcegc> Type(0);
}
\end{verbatim}
}

\section{L-values and R-values}

\paragraph{}
Loci uses the concept of L-values and R-values to provide a very simple way to implement move semantics. C++ supports copying as the primary operation for replicating values, however Loci instead uses move semantics by default. The latest version of C++ adds support for move operations, however this must be implemented on a per-type basis; Loci has no such complexities.

\small{
\begin{verbatim}
class SomeType(int * p){
    ~SomeType(){
        // This destructor is only run
        // if the object is non-empty.
        delete @p;
    }
}

SomeType f(){
    // Return r-value.
    return SomeType(new 1);
}

void function(){
    // Constructor called, and value moved into stack.
    // (This would be optimised to construction on the stack.)
    SomeType a = SomeType(new 2);
    
    SomeType b = SomeType(new 3);
    
    // Existing value in 'a' destroyed (destructor called),
    // value in 'b' moved into 'a', and 'b' is now left
    // empty (i.e. b == null).
    a = #(b);
    
    // Value returned from 'f' moved into 'b', which is now
    // non-empty.
    b := f();
}
\end{verbatim}
}

\paragraph{}
This code shows the move semantics applied to a type `SomeType', for which the user has specified no special methods. In C++, such code would require defining a copy constructor (or a move constructor in the latest version) and an assignment method, which might look similar to the following:

\small{
\begin{verbatim}
// This is C++ code!
class SomeType{
    public:
        SomeType(int * p){
            p_ = p;
        }
        
        SomeType& operator=(const SomeType& t){
            // Avoid self-assignment.
            if(&t != this){
                // Destroy existing local state.
                delete p_;
                
                // Copy state.
                p_ = t.p_;
                
                // Zero state in 't'.
                t.p_ = 0;
            }
            return *this;
        }
        
        ~SomeType(){
            // Check whether the object is empty.
            if(p_ == 0){
                delete p_;
            }
        }
    
    private:
        int * p_;
    
};
\end{verbatim}
}

\paragraph{}
Clearly, C++ requires a large amount of code to produce similar semantics; Loci generates this code on behalf of the user, saving the programmer time in terms of both development and testing.

\section{Vector Types}

\paragraph{}
Loci supports SIMD operations directly through the use of vector types, allowing operations such as addition to be applied in parallel to a vector of integer or floating point values.

\small{
\begin{verbatim}
void function(){
    int[4] a = {0, 1, 2, 3};
    int[4] b = {5, 6, 7, 8};
    int[4] c = a + b;
    
    // The resulting values.
    assert(c[0] == 5);
    assert(c[1] == 7);
    assert(c[2] == 9);
    assert(c[3] == 11);
}
\end{verbatim}
}

\paragraph{}
The ternary operator also provides some interesting behaviour for vectorised types:

\small{
\begin{verbatim}
void function(){
    int[4] a = {0, 1, 2, 3};
    int[4] b = {4, 5, 6, 7};
    bool[4] c = {true, false, true, false}
    
    int[4] d = c ? a : b;
    
    // The resulting values.
    assert(d[0] == 0);
    assert(d[1] == 5);
    assert(d[2] == 2);
    assert(d[3] == 7);
}
\end{verbatim}
}

\section{Primitive Syntactic Sugar}

\paragraph{}
The C standard library provides some basic mathematical routines to perform simple operations:

\small{
\begin{verbatim}
void function(){
    float a = -1.5;
    float b = fabs(a);
    float c = floor(b);
    float d = sqrt(c);
    printf("%f\n", d);
}
\end{verbatim}
}

\paragraph{}
Through the compatibility with C, these routines clearly remain available in Loci, however some syntactic sugar is provided to make it slightly cleaner to express these operations:

\small{
\begin{verbatim}
void function(){
    float a = -1.5;
    float b = a.abs();
    float c = b.floor();
    float d = c.sqrt();
    
    String s = d.toString();
    printf("%s\n", s.c_str());
}
\end{verbatim}
}

\paragraph{}
These modifications turn the primitive types into object types, although the implementation is identical to C. While these syntactic changes are fairly trivial, this is very helpful for expressing the capabilities of a type in templates (discussed later).

\section{Algebraic Datatypes}

\paragraph{}
Functional languages such as ML and Haskell provide algebraic datatypes as a mechanism for holding information, which may itself be of a number of different types. The following is a clear example of such a case, implemented in Loci:

\small{
\begin{verbatim}
data BinaryTree{
    data Leaf(int v){
        String toString(){
            return "Leaf(" + @v.toString() + ")";
        }
    }
    
    data Node(BinaryTree& left, BinaryTree& right){
        String toString(){
            return "Node(" + @left->toString() +
                ", " + @right->toString() + ")";
        }
    }
};
\end{verbatim}
}

\paragraph{}
In this case, a binary tree element is either a Leaf which contains only an integer value, or a Node that contains two trees as its left and right children.

\paragraph{}
It is common to need to describe such types when handling lots of data (for example, building ASTs in a compiler), and also in general programming. Expressing similar structures in C or C++ requires the combination of enums, unions and structs, and furthermore unions and class types interact poorly in C++.

\paragraph{}
Defining the structure isn't useful alone, so Loci introduces the `typeswitch' statement:

\small{
\begin{verbatim}
void function(BinaryTree tree){
    typeswitch(tree){
        case BinaryTree:Leaf(int v){
            printf("It's a leaf of value %i.\n", v);
        }
        case BinaryTree:Node{
            printf("It's a node.\n");
        }
    }
}
\end{verbatim}
}

\paragraph{}
This statement has some specific semantics:

\begin{enumerate}
\item The sub-types (in this case, `Leaf' and 'Node') in the switch statement must be the complete set of sub-types within the parent type (`BinaryTree'); if any types are missed, compilation fails. However unspecified sub-types can be handled using a `default' entry.
\item Case statements can capture values within the data types. In the example the value in the leaf is captured so it can be printed to the command line.
\item No `break' statement is required to exit the typeswitch, since this is almost always the desired behaviour and therefore requiring it is tedious for the programmer\footnote{Also, the behaviour is unintuitive for developers who are new to C-style languages.}. However, `continue' can be used to provide the behaviour of moving to the next case if desired.
\end{enumerate}

\section{Named Parameters}

\small{
\begin{verbatim}
bool canFind(String needle, String haystack);

void function(){
    // Normal call.
    bool found0 = canFind("world", "Hello world!");
    
    // Named parameter call.
    bool found1 = canFind(haystack: "Hello world!", needle: "world");
}
\end{verbatim}
}

\section{Exceptions}

\paragraph{}
There has been (and is continuing to be) much debate on the relative merits of `checked' exceptions, `unchecked' exceptions and C-style error checking (along with other variants).

\paragraph{}
Based on the outcome of this debate, Loci uses unchecked exceptions as a standard method for functions to report some form of failure, since these trigger fewer architectural maintenance problems.

\small{
\begin{verbatim}
exception A(String what);
exception B(String what, int i) : A(what);

void f(int i){
    if(i < 0){
        throw B("Function 'f' passed negative value.", i);
    }
}

void caller(){
    try{
        f(-1);
    }catch(A a){
        printf("Something (bad) happened: %s\n", a.what);
        throw;
    }
}
\end{verbatim}
}

\paragraph{}
A stack trace is also constructed while these exceptions are in flight, and in the case that the exception reaches the top level of the program (i.e. the main function), the stack trace is printed along with the contents of the exception type.

\section{Faults}

\paragraph{}
Unlike C or C++ (but a lot like Java), Loci converts program errors such as SEGFAULTs into exceptions, to take advantage of the ability to catch exceptions and produce stack traces.

\small{
\begin{verbatim}
int f(int * i){
    return *i;
}

int g(int[4] v, int i){
    return v[i];
}

void h(int v){
    assert(v >= 0);
}

void caller(){
    try{
        printf("%i\n", f(null));
    }catch(NullPointerException e){
        printf("Null pointer exception!\n");
    }
    
    try{
        int[4] v;
        printf("%i\n", g(v, 100));
    }catch(VectorIndexOutOfBoundsException e){
        printf("Vector index out of bounds!\n");
    }
    
    try{
        h(-1);
    }catch(AssertionFailedException e){
        printf("Assertion failed!\n");
    }
}
\end{verbatim}
}

\section{Templates}

\paragraph{}
Loci implements templates, to provide parametric polymorphism, which is useful for defining the types of collections (along with many other things).

\small{
\begin{verbatim}
class Class<type T>(T v){ }
\end{verbatim}
}

\paragraph{}
This code shows the creation of a class that has a type parameter `T'. In C++, instances of this class would be generated by the compiler for each type given as type `T'. So the following C++ code would generate four different classes in the resulting code:

\small{
\begin{verbatim}
Class<int> cInt;
Class<float> cFloat;

struct T{ int a; float b; };
Class<T> cT;

Class<T *> cTPtr;
\end{verbatim}
}

\paragraph{}
However, in Loci the compiler only creates one instance of the class, which works correctly for all possible types for T. However this requires something similar to auto-boxing\footnote{Without the need to store such values on the heap.} for primitive types, which is potentially very slow, so its possible to instruct the compiler to create particular instances of a class, using code such as the following:

\small{
\begin{verbatim}
instance Class<int>;
instance Class<float>;

struct T{ int a; float b; };
instance Class<T>;

instance Class<T *>;
\end{verbatim}
}

\paragraph{}
This then creates the generic version of the class by default, but if the type is int, float, T or T*, the corresponding specialised (and therefore presumably faster) type is used.

\end{document}













