__primitive null_t { }

__primitive bool {
	bool implicitCopy() const;
	
	bool not() const;
}

__primitive char {
	char implicitCopy() const;
	
	int compare(char v) const;
	
	bool isZero() const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

__primitive short {
	short implicitCopy() const;
	
	short abs() const;

	short add(short v) const;
	short subtract(short v) const;
	short multiply(short v) const;
	short divide(short v) const;
	short modulo(short v) const;
	
	int compare(short v) const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

__primitive int {
	int implicitCopy() const;
	
	int abs() const;

	int add(int v) const;
	int subtract(int v) const;
	int multiply(int v) const;
	int divide(int v) const;
	int modulo(int v) const;
	
	int compare(int v) const;
	bool isZero() const;
	bool isPositive() const;
	bool isNegative() const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

__primitive long {
	long implicitCopy() const;
	
	long abs() const;

	long add(long v) const;
	long subtract(long v) const;
	long multiply(long v) const;
	long divide(long v) const;
	long modulo(long v) const;
	
	int compare(long v) const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

__primitive float {
	float implicitCopy() const;

	float abs() const;

	float add(float v) const;
	float subtract(float v) const;
	float multiply(float v) const;
	float divide(float v) const;
	float modulo(float v) const;
	
	int compare(float v) const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

__primitive double {
	double implicitCopy() const;
	
	double abs() const;

	double add(double v) const;
	double subtract(double v) const;
	double multiply(double v) const;
	double divide(double v) const;
	double modulo(double v) const;
	
	int compare(double v) const;
	
	/*char toChar() const;
	short toShort() const;
	int toInt() const;
	long toLong() const;
	float toFloat() const;
	double toDouble() const;*/
}

template <typename T>
__primitive ptr {
	static ptr<T> Null();
	
	ptr<T> implicitCopy() const;
	
	lval<T> ptr_lval<T> deref();
	
	lval<T> ptr_lval<T> index(int index);
}

template <typename T>
__primitive ptr_lval {
	T* address();
	void assign(T value);
	T& dissolve() const;
}

template <typename T>
__primitive value_lval {
	static value_lval<T> Create(T value);
	T* address();
	void assign(T value);
	T& dissolve() const;
	T move();
}

template <typename T>
__primitive member_lval {
	static member_lval<T> Create(T value);
	T* address();
	void assign(T value);
	T& dissolve() const;
}

/*
Eventually the following will be adopted for use (once compile-time evaluation
has been implemented). For now, this stuff is still built-in to the compiler.

template <virtual typename T>
__primitive ref {
	ref<T> implicitCopy() const;
	T implicitDeepCopy() const;
	
	do (synthesizer) {
		// Add any methods from the referred-to type
		// that aren't part of this type.
		for (auto method: T.dynamic_methods()) {
			if (synthesizer.has_dynamic_method(method.name())) break;
			synthesizer.add_dynamic_method(method.returnType(), method.name(), method.argTypes()) const;
		}
	}
}

__primitive method {
	typename returnType() const;
	typename[] paramTypes() const;
}

interface None { }

template <virtual typename Constraint = None>
__primitive typename {
	bool has_static_method(string name) const;
	method get_static_method(string name) const;
	
	bool has_dynamic_method(string name) const;
	method get_dynamic_method(string name) const;
	
	do (synthesizer) {
		// 'call' calls the default constructor, if any exists.
		if (!Constraint.has_static_method("default")) break;
		auto method = Constraint.get_static_method("default") const;
		synthesizer.add_dynamic_method(method.returnType(), "call", method.argTypes()) const;
	}
	
	do (synthesizer) {
		// All constructors can be called by
		// name, as methods of this object.
		for (auto method: Constraint.static_methods()) {
			if (synthesizer.has_method(method.name())) break;
			synthesizer.add_dynamic_method(method.returnType(), method.name(), method.argTypes()) const;
		}
	}
}

template <virtual typename Constraint = None>
__primitive virtual_typename {
	bool has_static_method(string name) const;
	method get_static_method(string name) const;
	
	bool has_dynamic_method(string name) const;
	method get_dynamic_method(string name) const;
}

template <typename T, typename Ret, typename[] Param>
class interface_method(T* objectPtr, void* vtable, uint32_t value) {
	static Create(T* objectPtr, void* vtable, uint32_t value) {
		return @(objectPtr, vtable, value) const;
	}
	
	interface_method<T, Ret, Param> implicitCopy() const {
		return interface_method(@objectPtr, @vtable, @value) const;
	}
	
	Ret call(Param args[]) const {
		auto vtableArray = static_array<void *>(@vtable) const;
		auto f = function_ptr<Ret, {T*} + Param>(
		f(@objectPtr, args) const;
	}
}*/


