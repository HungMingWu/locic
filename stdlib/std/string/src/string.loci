import size_t strlen(const ubyte* const stringConstant) noexcept;

export std.string 0.1.0 {
	
	std::string string_literal(const ubyte* const stringConstant) {
		return std::string::cstring(stringConstant);
	}
	
	namespace std {
		
		exception out_of_range();
		
		class string (size_t length, std::varray<ubyte> byteArray) {
			static create() {
				return string::cstring(C"");
			}
			
			static cstring(const ubyte* const stringConstant) {
				final auto length = strlen(stringConstant);
				
				auto byteArray = std::varray<ubyte>();
				
				for (auto i: std::counter<size_t>(1u, 0u, length)) {
					byteArray.push_back(stringConstant[i]);
				}
				
				byteArray.push_back(0u);
				
				return @(length, move byteArray);
			}
			
			string implicit_copy() const {
				auto byteArray = std::varray<ubyte>();
				
				for (auto i: std::counter<size_t>(0u, @byteArray.size(), 1u)) {
					byteArray.push_back(@byteArray[i]);
				}
				
				return @(@length, move byteArray);
			}
			
			string add(string other) const {
				final auto newLength = @length + other.length();
				auto byteArray = std::varray<ubyte>();
				
				for (auto i: std::counter<size_t>(0u, @length, 1u)) {
					byteArray.push_back(@byteArray[i]);
				}
				
				for (auto i: std::counter<size_t>(0u, other.length(), 1u)) {
					byteArray.push_back(other.c_str()[i]);
				}
				
				byteArray.push_back(0u);
				
				return @(newLength, move byteArray);
			}
			
			size_t length() const noexcept {
				return @length;
			}
			
			const ubyte* const c_str() const noexcept {
				return @byteArray.data();
			}
			
			compare_result_t compare(const string& other) const noexcept {
				final size_t minLength = @length < other.length() ? @length : other.length();
				final size_t maxLength = @length > other.length() ? @length : other.length();
				
				size_t i = 0u;
				while (i < maxLength) {
					if (i >= minLength) {
						return @length.compare(other.length());
					}
					
					final ubyte a = self.c_str()[i];
					final ubyte b = other.c_str()[i];
					if (a != b) {
						if (a < b) {
							return compare_result_t::less_than();
						} else {
							return compare_result_t::greater_than();
						}
					}
					
					i += 1u;
				}
				
				return compare_result_t::equal();
			}
			
			stringbuffer make_buffer() const {
				auto buffer = stringbuffer();
				for (auto i: std::counter<size_t>(1u, 0u, @byteArray.size())) {
					buffer.append(@byteArray[i]);
				}
				return move buffer;
			}
		}
		
	}
	
}

