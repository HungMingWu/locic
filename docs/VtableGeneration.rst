Vtable Generation
=================

As explained in :doc:`Primitive Objects <PrimitiveObjects>`, Loci allows code such as the following:

.. code-block:: c++

	interface IntAbs {
		int abs() const;
	}
	
	void polymorphicFunction(const IntAbs& value) {
		printf(C"abs() value: %d\n", value.abs());
	}
	
	void exampleFunction() {
		int i = -1;
		int j = 0;
		int k = 1;
		
		polymorphicFunction(i);
		polymorphicFunction(j);
		polymorphicFunction(k);
	}

That is, primitive types such *int* and *long* operate equivalently to user-defined types for :doc:`Dynamic Dispatch <DynamicDispatch>`. Further, :doc:`Structural Typing <StructuralTyping>` allows code such as:

.. code-block:: c++

	class Bucket {
		static Create(int v);
		
		bool containsValue() const;
		
		void placeValue(int value);
		
		int getValue() const;
	}
	
	interface ValueHolder {
		bool containsValue() const;
		
		int getValue() const;
	}
	
	int f(const ValueHolder& valueHolder) {
		return valueHolder.getValue();
	}
	
	void function() {
		Bucket bucket = Bucket(2);
		int value = f(bucket);
	}

So it's also possible to cast a class reference to an interface reference (and an interface reference to another interface reference) if the types are structurally compatible. These features require implementation considerations about:

* When a Vtable is generated
* How a Vtable is accessed
* How a Vtable is structured

The first two issues are discussed here; the latter is discussed in :doc:`Dynamic Dispatch <DynamicDispatch>`.

In C++
------

The above features are not provided by C++, due to the implementation choices related to vtables. Specifically, C++ partitions types at compile-time into *virtual* and *non-virtual* types, with the category of a type being *virtual* if it (or any of its ancestors) contain one or more virtual methods, and *non-virtual* otherwise. For example:

.. code-block:: c++

	// This is C++ code!
	class VirtualType {
		public:
			virtual int getValue() const;
			
	};
	
	class NonVirtualType {
		public:
			int getValue() const;
			
	};

If a type is determined to be *virtual*, all instances of the type will typically contain a pointer to its vtable, which will almost always be at the start of the object's memory space.

In Loci
-------

Due to :doc:`Structural Typing <StructuralTyping>` (where a class doesn't need to declare which interfaces it implements), if Loci used the same typical C++ implementation then **all types** would be considered virtual, since they may potentially be used in a polymorphic manner (this would even include primitive types).

Fortunately, Loci doesn't do this. All objects contain only their member variables, and do **not** contain a pointer to the type's vtable. Furthermore, in most cases the vtable won't be generated at all.

This is achieved by instead holding the vtable pointer in a polymorphic reference type, and hence only generating the vtable for casts from non-polymorphic references to polymorphic references. For example:

.. code-block:: c++

	interface DoSomethingAble {
		void doSomething();
	}
	
	class ExampleClass() {
		void doSomething() { }
	}
	
	void polymorphicFunction(DoSomethingAble& object) {
		object.doSomething();
	}
	
	void nonPolymorphicFunction(ExampleClass& object) {
		polymorphicFunction(object);
	}

The reference parameter received by *nonPolymorphicFunction* is just a pointer to the object. The vtable is generated by the compiler when it sees this cast:

::

	ExampleClass& -> DoSomethingAble&

As mentioned above, the former reference is just a pointer. However, the latter also contains a pointer to the vtable (as well as a :doc:`Template Generator <TemplateGenerators>`).

The consequences of this implementation choice are:

* Vtables are only generated by the compiler when required.
* Objects do not contain anything other than their member variables (i.e. no object 'header').
* As shown above, this means we can use primitive types polymorphically.
* Polymorphic objects **cannot** be referenced by just a C pointer (usually this can easily be worked-around by the Loci developer).

