\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{caption}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subfig}

\lstset{basicstyle=\ttfamily\scriptsize,
	language=C++,
	keywordstyle=\textbf,
	frame=single,
	breaklines=true,
	tabsize=2,
	showstringspaces=false,
	float=t}

\lstloadlanguages{
         C,
         C++,
         Java
 }


\title{Loci Programming Language}
\author{Stephen Cross}

\raggedbottom						   % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}	   % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}	% adjust line spacing to make
										% more readable

\begin{document}

%%%%%%%%%%%%% TITLE PAGE %%%%%%%%%%%%%
\pagestyle{empty}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Loci Programming Language} \\
\vspace*{5mm}
Stephen Cross \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%% TABLE OF CONTENTS %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\tableofcontents

\listoffigures

\cleardoublepage

%%%%%%%%%%%%% CONTENT %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

\paragraph{}
The C programming language is a widely used programming language and compilers are available for almost all architectures. Furthermore, many programming languages provide the means to call into/out-of C, facilitating inter-operation of different programming languages with C as a `bridge'. While technically useful, the C programming language is often perceived as lacking sufficiently powerful abstractions to construct large and complex systems. For this reason, languages such as C++, Objective C and D were invented to provide abstractions on top of the language.

\paragraph{}
Unfortunately, these languages have significant problems. For example, C++ and D place undue attention to compile-time functionality that serves to complicate the source code. Interestingly, Objective-C shifts the vast majority of the burden to run-time, and hence uses weak typing. Preference of programming languages is certainly based on the opinion of individual programmers, however languages also face general criticism. In particular, C++ attracts criticism due to its large set of features and rules that ultimately combine to produce complex semantics. Equally, however, programmers support the combination of powerful features as found in a multi-paradigm language such as C++.

\paragraph{}
The design of languages that are both simple and powerful is difficult, and popular existing programming languages represent a variety of reasonable solutions. A number of newer languages have emerged that operate at a `higher level' than languages such as C and C++, of which examples are Java and C\#. Typically, these languages use primitives and pointers as fundamental types, deploy some form of garbage collection, use classes as their fundamental data structures and provide the means to construct inheritance hierarchies. There is a disputed performance cost to using these languages over lower level languages, which is generally found to be small and hence arguably insignificant.

\paragraph{}
However, these languages also suffer significant problems: there are no deterministic destruction routines (which must be provided by the programmer through constructs such as try...finally), the languages have extensive dependencies on the large and complex environment that supports them and they lack direct access to lower level routines typically available in C. Furthermore, despite aims to remain simple, many of these languages have become increasingly complex as it is discovered the initial design was insufficiently powerful. Special cases (e.g. Java's + operator for strings) further serve to complicate the languages.

\section{Aims}

\paragraph{}
This document therefore describes and rationalises the design of the Loci programming language, which aims to provide strong compatibility with C, while adding useful efficient high level abstractions, and without the complexities that arise in C++.

\paragraph{}
Loci should satisfy the following (quite vague) goals:

\begin{itemize}
\item Modular - The language must help to produce programs in which the basic problem is split into distinct components, which can be easily re-combined to solve other problems.
\item Portable - The language should be independent of any specific machine architecture or operating system, such that programs can be ported easily.
\item Compatible - The language must be compatible with existing languages/standards so that it can make use of existing services.
\item Simple - The language must remove all unnecessary complexity and maximize developer efficiency so that time can be best spent solving the problem at hand. It is important to reduce the learning curve to remove any barriers preventing new developers from embracing the language.
\item Clean - The language must help to produce clean and consistent applications which can be easily read and understood. It is important that when one developer sees code written by another developer it is easy for them to understand it, in order to aid collaboration.
\item Small - The language must produce resulting code that is small and free of dependencies except those specified in the program and understood to the developer, such that distribution is simple and fast.
\item Fast - The language must provide good performance, to maximise its utility.
\end{itemize}

\section{Name}

\paragraph{}
While it has been suggested that Loci could stand for `Loci: objects, classes and interfaces', this is not the intended understanding because the language is much more than just being object orientated\footnote{Like C++, Loci is a multi-paradigm language.}. Instead, the name reflects the following definitions of its singular form:

\begin{quotation}
\emph{locus} - the set of all points or lines that satisfy or are determined by specific conditions
\end{quotation}
\begin{quotation}
\emph{locus} - A place or locality, especially a centre of activity
\end{quotation}

\section{Specific Goals}

\paragraph{}
Establishing this basis for Loci, it is possible to elaborate more specific goals for the language:

\begin{itemize}
\item \textbf{Provide stable interfaces between modules.} A change in one module should not require a module that depends on it to be re-compiled, unless there are changes that break the API. In particular, classes in libraries can change their internal structure (i.e. their member variables) without requiring re-compilation of clients of the library.
\item \textbf{Follow a standard binary interface for each platform.} Modules compiled by different compilers must work together. Loci creates standard C functions with fixed naming rules and calling conventions.
\item \textbf{Fast compile times.} This is vital to maximise productivity. Loci files are effectively isolated from each other, such that they can be tokenized and parsed in parallel, and then the resulting structures can be used to resolve and verify dependencies. Effectively parallelising builds for other languages is often significantly more complex.
\item \textbf{Minimal syntactic complexity.} For example, header guards are required in C to prevent a header from being included twice. In Loci all files are equal and are only analyzed once, so there is no need to add any sort of guards. Furthermore the Loci compiler uses multiple passes so type declarations/definitions do not have to appear before their use.
\item \textbf{Minimal semantic complexity.} Loci avoids language features (or combinations of language features) that affect the readability and predictability of code. For example, Loci does not support function or method overloading, since these can easily increase the complexity of the language with little to no added benefit.
\item \textbf{Provide a powerful polymorphism mechanism.} Loci provides interfaces, that are effectively equivalent to C++ pure virtual classes with a virtual destructor, or Java interfaces. Loci uses structural typing, so casts are allowed from classes to interfaces if the class provides all the methods required by the interface.
\end{itemize}

\cleardoublepage

\chapter{Design}

\paragraph{}
Loci is very closely related to C in both syntax and semantics, with the ability to call C functions (and be called from C) easily and to handle C types. Numerous ideas from languages such as C++, Java, Objective C, ML and Python are also used\footnote{Although in varying amounts; the language certainly pulls more ideas from C++ than any other language.} to develop the features and abstractions that Loci provides on top of the basic functionality of C.

\paragraph{}
A primary concern for the language design is closely resembling the `look and feel' of languages such as C and C++, with the intention that developers familiar with those languages should be able to easily get started in Loci. Syntactic or semantic divergences from existing languages are justified in this document.

\paragraph{}
Loci emphasises providing choice for the programmer, in the form of features that are each suited for particular purposes, where such features interact well with the rest of the language. A good example is algebraic data types, which are well suited to expressing data such as ASTs\footnote{Abstract Syntax Trees, which are constructed in a compiler front-end and approximately express the structure of the input source code.}.

\paragraph{}
However, as well as using ideas from many languages, Loci also specifically rejects some features, such as method/function overloading, class inheritance and weak typing\footnote{Specifically, a large set of legal implicit casts. For example, in C, it is valid to implicitly cast from `void *' to `int *'.}. Each of the features left out are considered at least unnecessary and potentially harmful, and interact poorly with the surrounding environment.

\paragraph{}
In addition, Loci modifies well known features to make them easier to use, to help the programmer avoid common pitfalls and as an attempt to fix the flaws in some programming languages that are now evident in hindsight. The language also attempts to help programmers verify code correctness and to make code reasonably self-documenting.

\paragraph{}
This section explains and justifies some of the design decisions made within the language; the following section then shows how these features are implemented. Each design decision was made with a good understanding of how it would be implemented, in particular to minimise the compiler complexity\footnote{And correspondingly, the time taken for compilation.}, code dependencies and code size, and to maximise the performance.

\section{Language}

\subsection{C}

\paragraph{}
As mentioned previously, Loci is highly related and compatible with C. It therefore supports:

\begin{itemize}
\item Primitive types (e.g. `int').
\item Pointer types.
\item Struct types.
\item Enum types.
\item Union types.
\item Function pointer types.
\item C's calling convention, so it can call and be called from C functions.
\end{itemize}

\subsubsection{Syntax}

\paragraph{}
There are however, some minor syntactic changes. For example, like C++, struct type names do not need need to be prefixed with the struct name except when they are defined:

\begin{lstlisting}
struct A{
	int v;
};

void function(){
	// Valid, but `struct' keyword is unnecessary.
	struct A a;
	
	// Valid, and same as above.
	A a;
}
\end{lstlisting}

\paragraph{}
This syntactic change applies similarly for enum and union types. The intention, clearly, is to reduce the verbosity of the code and therefore the burden on the programmer to write it.

\paragraph{}
Casts also use a different syntax:

\begin{lstlisting}
void function(){
	float pi = 3.141592654;
	
	// Invalid.
	int intPi = (int) pi;
	
	// Valid.
	int intPi = cast<int>(pi);
}
\end{lstlisting}

\paragraph{}
The new syntax is much clearer, helping readers to understand exactly what value is being cast, since the precedence of the type cast may not be obvious\footnote{Few programmers remember all (or close to all) of their language's operator precedences.} Consider this example:

\begin{lstlisting}
void function(Type * ptr, Type::*function()){
	// As one expects...
	int i = (int) ptr->member;
	
	// ...is equivalent to this.
	int i = ((int) ptr->member);
	
	// But this...
	int i = (int) ptr->member + 1;
	
	// ...is equivalent to this.
	int i = ((int) ptr->member) + 1;
	
	// And this (C++ code)...
	int i = (int) ptr->*function();
	
	// ...would be equivalent to this.
	int i = ((int) ptr)->*function();
	
	// (Which is of course broken.)
	
}
\end{lstlisting}

\subsubsection{Semantics}

\paragraph{}
There are also some minor semantic changes, in particular to the available implicit casts:


\begin{lstlisting}
void function(){
	float pi = 3.141592654f;
	
	// Invalid - no implicit cast.
	int intPi = pi;
	
	// Valid - explicit cast is allowed.
	int intPi = cast<int>(pi);
	
	// Invalid - no implicit cast from 'void *' to 'int *'.
	int * intPtr = malloc(sizeof(int));
	
	// Valid.
	int * intPtr = reinterpret_cast<int *>(malloc(sizeof(int)));
	
	
}
\end{lstlisting}


\paragraph{}
In this case, the intention is to make it clear to a reader when values are being cast to fundamentally different types (such as an integer and a floating point value). The `cast' operator supports legal implicit and explicit casts, whereas the `reinterpret\_cast' operator allows casts between pointers whose target types (i.e. the type being pointed-to) are different.

\clearpage

\subsection{Type Syntax}

\paragraph{}
Loci strictly follows the following structure for all typed variables declarations:


\begin{lstlisting}
[TYPE] [NAME]
\end{lstlisting}


\paragraph{}
This differs significantly from C, in which types and names can overlap in confusing ways, such as in function pointer types:


\begin{lstlisting}
void (*f)(); // C
void (*)() f; // Loci

int (*f)(); // C
int (*)() f; // Loci

int (*f)(int, int); // C
*(int)(int, int) f; // Loci
\end{lstlisting}


\paragraph{}
Similarly, typedefs are much clearer in Loci:

\begin{lstlisting}
typedef ReturnType (*NewName)(ParamType param); // C
typedef *(ReturnType)(ParamType) NewName; // Loci
\end{lstlisting}


\clearpage

\subsection{Modules}

\subsubsection{Header Files}

\paragraph{}
In C and C++, no source file can access the structs or functions implemented by another file unless it has its own declarations. Here's an example in C++:

\begin{lstlisting}
// Source file 'A.cxx'.

struct SomeStruct{ int i; };

SomeStruct function(){
	SomeStruct s;
	s.i = 42;
	return s;
}
\end{lstlisting}

\begin{lstlisting}
// Source file 'B.cxx'.

struct SomeStruct{ int i; };
SomeStruct function();

int main(){
	SomeStruct s = function();
	printf("Number is %d.\n", s.i);
	return 0;
}
\end{lstlisting}

\paragraph{}
In this case, file `B.cxx' must provide declarations for the implementations in file `A.cxx', since the compiler compiles each source file separately and therefore without reference to other source files.

\paragraph{}
This is of course problematic if the structures and functions defined in one source file need to be used in many source files, particularly if there are many functions, in which case re-writing the declarations for each source file wastes development time. The solution is to use header files:

\begin{lstlisting}
// Header 'Header.hpp'.

struct SomeStruct{ int i; };
SomeStruct function();
\end{lstlisting}

\begin{lstlisting}
// File 'A'.
#include "Header.hpp"

SomeStruct function(){
	SomeStruct s;
	s.i = 42;
	return s;
}
\end{lstlisting}

\begin{lstlisting}
// File 'B'.
#include "Header.hpp"

int main(){
	SomeStruct s = function();
	printf("Number is %d.\n", s.i);
	return 0;
}
\end{lstlisting}

\paragraph{}
Header files take advantage of the preprocessor, via an \#include, to copy the text from a header file directly into a number of source files.

\subsubsection{Header Guards}

\paragraph{}
Headers may also need to include each other, but unfortunately this can create problems:

\begin{lstlisting}
// Header 'Header1.hpp'.

struct SomeStruct{ int i; };
\end{lstlisting}

\begin{lstlisting}
// Header 'Header2.hpp'.
#include "Header1.hpp"

SomeStruct function();
\end{lstlisting}

\begin{lstlisting}
// File 'A'.
#include "Header1.hpp"
#include "Header2.hpp"

SomeStruct function(){
	SomeStruct s;
	s.i = 42;
	return s;
}
\end{lstlisting}

\begin{lstlisting}
// File 'B'.
#include "Header2.hpp"

int main(){
	SomeStruct s = function();
	printf("Number is %d.\n", s.i);
	return 0;
}
\end{lstlisting}

\paragraph{}
This will cause an error in `A.cxx' since the header `Header1.hpp' is included twice, and therefore the struct definition appears twice in its code, which is not allowed in C or C++. The solution to this problem is header guards:

\begin{lstlisting}
// Header 'Header1.hpp'.

#ifndef HEADER1_HPP
#define HEADER1_HPP

struct SomeStruct{ int i; };

#endif
\end{lstlisting}

\begin{lstlisting}
// Header 'Header2.hpp'.

#ifndef HEADER2_HPP
#define HEADER2_HPP

#include "Header1.hpp"

SomeStruct function();

#endif
\end{lstlisting}

\begin{lstlisting}
// File 'A'.
#include "Header1.hpp"
#include "Header2.hpp"

SomeStruct function(){
	SomeStruct s;
	s.i = 42;
	return s;
}
\end{lstlisting}

\begin{lstlisting}
// File 'B'.
#include "Header2.hpp"

int main(){
	SomeStruct s = function();
	printf("Number is %d.\n", s.i);
	return 0;
}
\end{lstlisting}

\subsubsection{Loci Modules}

\paragraph{}
The C++ code above does manage to finally solve this problem, but at the expense of the creation of extra files and writing macros to protect headers. Most importantly, the above code duplicates information; all the information is available in the source files, so if the compiler were to analyse multiple source files together, the programmer need never write header files.

\paragraph{}
Put simply, this is exactly what happens in Loci. When you compile source files, you pass a group of files to the compiler which will then analyse them together and `extract' the appropriate declarations from definitions in the code. These groups will typically be all the files that produce a single static or shared library, or even an executable.

\paragraph{}
Note that this solution isn't complete, since libraries and executables do need to handle shared data structures and functions. For example, a library may define a specific API for use by the executable, but the library code should be compiled separately to the executable code.

\paragraph{}
Some sort of header files are needed for this case, which in Loci are simply normal `.loci' files that contain declarations as opposed to definitions. The particularly helpful aspect, in contrast to C or C++, is that Loci has tools to generate these `header files' for the developer.

\clearpage

\subsection{References}

\paragraph{}
TODO: UPDATE!

\paragraph{}
Loci references are in almost all ways identical to C++ references. The example below shows the syntax and semantics if the reader is unfamiliar:

\begin{lstlisting}
void function(int data, int * pointer){
	{
		// Invalid - no implicit cast from
		// pointer type to reference type.
		int& reference = pointer;
	}
	
	{
		// Valid - using dereference operator
		// to cast from pointer to reference.
		int& reference = *pointer;
	}
	
	{
		// Invalid - again, no implicit cast
		// from pointer type to reference type.
		int& reference = &data;
	}
	
	{
		// Valid - making reference of 'data'.
		int& reference = data;
	
		// Valid - updating lvalue referred to
		// by 'reference', which in this case
		// would be 'data'...
		reference = 1;
		
		// ...so this is equivalent.
		data = 1;
		
		// Invalid - type 'int' has no overload for
		// the dereference operator.
		*reference = 2;
		
		// Valid - copying reference lvalue to rvalue,
		// adding 5, and placing it into lvalue 'newData'.
		int newData = reference + 5;
	}
	
	{
		// Invalid - can't convert rvalue to non-const
		// lvalue reference.
		int& reference = 1;
	}
	
	{	
		// Valid - uses a special cast from rvalue to const
		// lvalue reference...
		const int& reference = 5;
		
		// ...which is basically equivalent to this.
		const int __unnamed_value = 5;
		const int& reference = __unamed_value;
	}
}
\end{lstlisting}

\clearpage

\subsection{Classes}

\paragraph{}
The ability to create and manipulate objects, which are instances of a class, provides a useful way to encapsulate a set of behaviour around a particular data type, and maintaining the necessary invariants needed by that type. Therefore Loci, like many other languages, includes support for object oriented programming.

\subsubsection{Definitions}

\paragraph{}
Here's an example of a Loci class definition:


\begin{lstlisting}
class Bucket(bool b, int value){
	bool containsValue() const{
		return @b;
	}
	
	void placeValue(int value){
		assert(!@b);
		@value = value;
	}
	
	int getValue() const{
		assert(@b);
		return @value;
	}
}
\end{lstlisting}


\paragraph{}
The organisation is somewhat different to many languages, and member variables are defined within the parentheses after the class name. The methods, constructors and destructors then appear within the braces that follow.

\paragraph{}
Another detail is that instance member variables are referred to using the @ symbol, which provides a clean alternative to the various C++ conventions for naming such variables\footnote{For example: `mValue' or `value\_'.}; such variables are also accessible through the use of the `this' pointer:


\begin{lstlisting}
	//...
	bool containsValue() const{
		return this->b;
	}
	//...
\end{lstlisting}


\subsubsection{Constructors}

\paragraph{}
The above example shows a class with no constructor, however there is an automatically generated constructor named `Default', so that the above is equivalent to:


\begin{lstlisting}
class Bucket(bool b, int value){
	static Default(bool b, int value){
		return @(b, value);
	}

	...
}

void function(){
	// Equivalent ways to call the default constructor.
	Bucket bucket = Bucket(true, 1);
	Bucket bucket = Bucket::Default(true, 1);
}
\end{lstlisting}


\paragraph{}
Here the @ symbol being called is the `internal constructor', and performs the actual construction of the class type\footnote{Which means, the process of filling the fields of the struct underlying the class with the values given to it.}. This system is intended as a superior alternative to initialization lists in C++ and Java. Here's an example of a C++ initialization list:


\begin{lstlisting}
// This is C++ code.
class Bucket{
	public:
		Bucket(bool b, int value)
			: b_(b), value_(value){ }
};
\end{lstlisting}


\paragraph{}
Avoiding initialization lists makes it easy to express complex logic in constructors, such as loops:


\begin{lstlisting}
class SomeClass(int value0, int value1){
	static Factorial(int n){
		int r = 1;
		for(int i = 2; i < n; i++){
			r *= i;
		}
		return @(r, r * r);
	}
};

void function(){
	SomeClass c = SomeClass::Factorial(10);
}
\end{lstlisting}


\paragraph{}
Other named constructors can also be created:


\begin{lstlisting}
class Bucket(bool b, int value){
	...
	
	static WithNoValue(){
		return @(false, 0);
	}
	
	static WithZeroValue(){
		return @(true, 0);
	}

	...
}

void function(){
	Bucket emptyBucket = Bucket::WithNoValue();
	Bucket zeroBucket = Bucket::WithZeroValue();
}
\end{lstlisting}


\subsubsection{Declarations}

\paragraph{}
Perhaps most interesting is the ability to declare classes. Unlike C++ where this is commonly needed, declarations typically won't be needed within a shared codebase, because Loci can find the class definitions and produce their corresponding declarations automatically.

\paragraph{}
Additionally, Loci uses multiple pass compilation so there is no requirement to define types or functions before they are used, and hence there is no need to declare a class which is later defined in the same code base, something that is common in C and C++.

\paragraph{}
However, if a class is to be used across an API boundary\footnote{For example, the class is defined inside a static library, and a program uses the declaration to create instances of the class and call its methods.} then declarations should be used.

\paragraph{}
Here's a declaration of the Bucket class:


\begin{lstlisting}
class Bucket{
	static Default(bool b, int v);

	bool containsValue() const;
	
	void placeValue(int value);
	
	int getValue() const;
}
\end{lstlisting}


\paragraph{}
Clearly, the class method implementations have been removed, however the member variables have also been removed. This is because, unlike C++, class declarations in Loci do \emph{not} need to include the types (or names) of the member variables.

\paragraph{}
From a design perspective, this prevents the need to use forward struct declarations (or similar) and heap allocations that are needed in C and C++, and is part of fulfilling Loci's goal to be an excellent language for defining, implementing and using APIs. Therefore clients of a library do not need to be recompiled when a class in the library changes its member variables, since this is private information.

\paragraph{}
Also note that the auto-generated default constructor has to be specified explicitly here, since users of the class declaration have no knowledge of the types (or number, or order) of the member variables and therefore cannot know the type of the constructor.

\clearpage

\subsection{Null}

\paragraph{}
C expresses the concept of null through the use of the NULL constant, which is of type `void *'. C++ expresses null through an implicit cast from the integer value 0 to a null pointer, or in the latest version through a specially defined constant of a special type.

\paragraph{}
Loci adds null in a similar way to the latest version of C++, where there is a universal constant `null' of type `null\_t', which has an implicit cast to any pointer type:


\begin{lstlisting}
void function(){
	// All valid.
	null_t n = null;
	int * i = n;
	int * j = null;
	float * f = null;
}
\end{lstlisting}


\paragraph{}
Custom types can also define a `null' constructor that essentially forms an implicit cast from `null\_t':

\begin{lstlisting}
class NullableCustomType{
	static Null();
}

class NonNullableCustomType{ }

void function(){
	// Implicitly calls 'NullableCustomType::Null()'.
	NullableCustomType nullableValue = null;
	
	// Invalid - compiler can't find the function
	// 'NonNullableCustomType::Null()'.
	NonNullableCustomType nonNullableValue = null;
}
\end{lstlisting}

\clearpage

\subsection{Const}

\paragraph{}
The `const' keyword is used in both C and C++ (as well as some other languages) to mark that data should not be modified by a specific section, or to indicate that a function guarantees to not modify its argument, or a method guarantees to not modify its owning object. Loci also provides `const', but with syntactic and semantic changes.

\subsubsection{Transitivity}

\paragraph{}
`const' is transitive in Loci, meaning that marking pointers or references as const also requires that the data they point to is marked const. This is embodied in a much cleaner and simpler syntax for denoting `const':

\begin{lstlisting}
// Valid.
const int ** pointerToPointerToConstInt;
const(int) ** pointerToPointerToConstInt;
const(int *) * pointerToConstPointerToConstInt;
const(int **) constPointerToConstPointerToConstInt;

// Invalid.
int const ** p;
int * const * p;
int ** const p;
\end{lstlisting}

\subsubsection{Logical Const}

\paragraph{}
Loci provides `const' to mark data as logically constant, which means that the fundamental memory contents of `const' objects may vary, as long as there is no change to the external behaviour of the object. ``No change to the external behaviour" means the following two functions `function' should be equivalent, and any transformation between them is valid:

\begin{lstlisting}
void f(const Type& value);
void g(const Type& value);

void function(){
	const Type var = SOME_EXPR;
	f(var);
	g(var);
}

void function(){
	const Type var = SOME_EXPR;
	const Type tmpVar = _copy_of_var_;
	f(var);
	g(tmpVar);
}
\end{lstlisting}

\paragraph{}
Here `\_copy\_of\_var\_' means a simple byte-for-byte copy of variable `var' that does not involve invoking a `copy' method, and furthermore that the destructor for `tmpVar' is not run. Therefore, this effectively means that the second function does not have to reload the value of the variable from memory, since it can assume that it has not changed.

\paragraph{}
Compilers are allowed to optimise\footnote{Note also that optimisations can only be performed where the compiler can prove that it has the only (const) reference to an object, otherwise other parts of the program may have non-const references to the object and thereby modify it in parallel, or as part of, the execution of the function with the const reference.} based on the validity of this transformation. This optimisation requires that `f' and `g' operate within type rules and don't use `const\_cast', and this is a requirement that the developer must follow. Consider, for example:

\begin{lstlisting}
using CString = char *;
void unknownStringOperation(const CString string);
void printSize(size_t size);
void printStringLength(const CString string){
	size_t length = 0;
	CString ptr = string;
	while(*ptr != 0x00){
		length++;
		ptr++;
	}
	printSize(length);
}

void function(){
	// Prefix 'C' means 'C string'; this is explained later.
	const CString string = C"This is a string";
	unknownStringOperation(string);
	printStringLength(string);
}
\end{lstlisting}

\paragraph{}
By the above equivalence, the compiler can assume this is equivalent to:

\begin{lstlisting}
// ... as above ...

void function(){
	unknownStringOperation(C"This is a string");
	printStringLength(C"This is a string");
}
\end{lstlisting}

\paragraph{}
Which, in combination with other transformations (such as inlining), leads to the optimised code:

\begin{lstlisting}
using CString = char *;
void unknownStringOperation(const CString string);
void printSize(size_t size);

void function(){
	unknownStringOperation(C"This is a string");
	printSize(cast<size_t>(16));
}
\end{lstlisting}

\subsubsection{Mutable}

\paragraph{}
As part of `logical const', Loci provides the `mutable' keyword, which allows developers to explicitly ignore const markers if needed:

\begin{lstlisting}
struct Struct{
	int normalField;
	mutable int mutableField;
};

void function(const Struct& ref){
	// Invalid - 'normalField' is now const.
	ref.normalField = 1;
	
	// Valid - mutable keyword overrides const.
	ref.mutableField = 1;
}
\end{lstlisting}

\paragraph{}
Following the rules of logical const, `mutable' should only ever be used when it has no effect on the external behaviour of an object. Again, this means the above transformation should apply. And since optimisations occur based on const, it is important that developers only use `mutable' when absolutely necessary and ensure correctness when it is used.

\paragraph{}
Of course this means the example given for `mutable' (involving the mutable field of a struct) is an incorrect use, since the field marked as `mutable' is directly accessible to functions `f' and `g'\footnote{Consider the case where `f' modifies the mutable field, and `g' reads it.}.

\paragraph{}
A good example of its correct use would be in a reference counting smart pointer class, in which the reference count field can (and should) be marked as `mutable'. Considering the transformation above once again, it doesn't matter whether `f' modifies the reference count\footnote{It could, for example, create a copy of the smart pointer and store it somewhere, increasing the reference count.}, because `g' only depends on a count greater than 0 (and the reference counting invariant is intended to ensure that is always true until the last smart pointer object is destroyed).

\paragraph{}
Marking class member variable mutexes as `mutable' is another example of a good use of the keyword, since `lock' and `unlock' methods modify the external behaviour of the mutex\footnote{Consider calling `lock' twice in a row, without calling `unlock'.} and therefore require it to be non-const, but any object that contains a mutex to handle races uses it in a way that does not affect its external behaviour (i.e. the above transformation is valid):

\begin{lstlisting}
class Mutex{
	void lock();
	void unlock();
}

class Lock(Mutex& mutex){
	static Default(Mutex& mutex){
		mutex.lock();
		return @(mutex);
	}
	
	~{
		@mutex.unlock();
	}
}

class CustomType(mutable Mutex mutex, Type value){
	void setValue(Type value){
		auto lock = Lock(@mutex);
		@value = value;
	}

	int getValue() const{
		// 'Lock' object will call 'lock'
		// and 'unlock' on the mutex.
		auto lock = Lock(@mutex);
		return @value;
	}
}
\end{lstlisting}

\subsubsection{Methods}

\paragraph{}
Methods can be marked as `const' to indicate they do not modify their owning object, as used above. Here's another example:

\begin{lstlisting}
class ClassObject{
	void normalMethod();
	void constMethod() const;
}

void f(const ClassObject& object){
	// Invalid - non-const method cannot
	// be called on const object.
	object.normalMethod();
	
	// Valid.
	object.constMethod();
}
\end{lstlisting}

\subsubsection{Casting Const Away}

\paragraph{}
Const can be cast away if needed with `const\_cast', but doing so could be very dangerous, since the compiler may be performing transformations as above. This means that the only valid use for const\_cast is to modify the type of a pointer to support an API that fails to use `const', but it is guaranteed that the API does not modify the object:

\begin{lstlisting}
void doSomething(int i);

void oldAPI(int * i){
	doSomething(*i);
}

void f(const int * i){
	oldAPI(const_cast<int *>(i));
}
\end{lstlisting}

\clearpage

\subsection{Primitive Objects}

\paragraph{}
The C standard library provides some basic mathematical routines to perform simple operations:


\begin{lstlisting}
void function(){
	float a = -1.5;
	float b = fabs(a);
	float c = floor(b);
	float d = sqrt(c);
}
\end{lstlisting}


\paragraph{}
Through the compatibility with C, these routines clearly remain available in Loci. However, Loci `revamps' the primitive types to be object types:


\begin{lstlisting}
void function(){
	float a = -1.5;
	float b = a.abs();
	float c = b.floor();
	float d = c.sqrt();
}
\end{lstlisting}


\paragraph{}
These modifications turn the primitive types into object types from the developer's perspective, even though the implementation is identical to C and there is therefore no performance penalty.

\paragraph{}
Syntactically, the change is quite significant, but there is also a considerable semantic difference since primitive references can be interface types, and primitives can satisfy template requirements that are based on their methods. Unlike C++, and surprisingly even Java, Loci provides a neat way to integrate primitives with other object types.

\clearpage

\subsection{Interfaces}

\paragraph{}
Java provides the concept of interfaces as equivalent to a pure virtual class in C++. This means that interfaces declare the methods that an implementing class must support, without providing any implementation of those methods. As compared to inheritance of classes, this is an ideal way to model the API of a class.

\paragraph{}
Loci uses, and extends, this concept by using interfaces as the basis for structural typing. This means that classes don't need to explicitly specify that they implement an interface, but if they have all the methods specified in the interface with the correct types and names then references to the class can be implicitly cast to references to the interface.

\paragraph{}
For example:


\begin{lstlisting}
class Bucket{
	static Default(int v);
	bool containsValue() const;
	void placeValue(int value);
	int getValue() const;
}

interface ValueHolder{
	bool containsValue() const;
	int getValue() const;
}

int f(const ValueHolder& valueHolder){
	return valueHolder.getValue();
}

void function(){
	Bucket bucket = Bucket(2);
	int value = f(bucket);
}
\end{lstlisting}


\paragraph{}
This clearly diverges from the approach taken by many languages, which is to requires classes to specify the interfaces they implement. However, the increased flexibility of this method allows interfaces to be defined \emph{after} classes have been defined, which would allow code like the following:


\begin{lstlisting}
interface LengthValue{
	size_t length() const;
}

size_t f(const LengthValue& lv){
	return lv.length();
}

void function(){
	std::string string = "Hello world!";
	size_t length = f(string);
}
\end{lstlisting}


\paragraph{}
`std::string' is a standard type, so is designed and implemented prior to the definition of the custom interface `LengthValue', and therefore it would be unlikely that standard library developers would foresee the need to implement that (or a similar) interface. However, structural typing allows the cast from `std::string\&' to `LengthValue\&' to be made because the types are in fact compatible.

\paragraph{}
As mentioned briefly previously, this functionality works equivalently well with primitive types:

\begin{lstlisting}
interface AbsInteger{
	int abs() const;
}

void f(const AbsInteger& value){
	if(value.abs() > 0){
		//...
	}
}

void function(){
	int value = 42;
	f(value);
}
\end{lstlisting}

\paragraph{}
The Implementation section discusses how this feature is implemented efficiently, in particular detailing how the performance of calling interface methods has a negligible overhead compared to existing virtual method calls in languages such as C++.

\clearpage

\subsection{New Operator}

\paragraph{}
Like C++, Loci provides the new operator, although the syntax and semantics are slightly different.


\begin{lstlisting}
class Type(int a){ }

Type f(){
	return Type(5);
}

void function(){
	// Stack and heap allocations, like in C++.
	Type stackAllocated = Type(0);
	Type * heapAllocated = new<raw> Type(0);
	
	// Allocates space on heap, and moves return
	// value of function 'f' from stack to heap.
	Type * heapMoved = new<raw> f();
	
	// Raw allocations must be deallocated.
	delete<raw> heapAllocated;
	delete<raw> heapMoved;
}
\end{lstlisting}


\paragraph{}
In particular, C++ forces the new operator to call a type constructor, so that stack objects are moved to the heap by a copy constructor. Loci, however, makes it easy to move objects without running any code (other than memcpy), and therefore the new operator was redesigned to be applied to any R-value (the details of which are described later) of the desired type, and will move that value onto the heap.

\paragraph{}
The new operator also requires the name of the memory management method to be used, which in the sample code above is `raw', meaning that the developer is responsible for calling delete on the pointers when finished with them (i.e. exactly like C++).

\clearpage

\subsubsection{Memory Management Methods}

\paragraph{}
The previous sample code showed `raw' allocations, in which allocation and construction of objects is performed as in C++. However, Loci supports other forms of allocation\footnote{And it is recommended for developers to avoid raw allocations as much as possible.}:


\begin{lstlisting}
void function(){
	// Automatically freed when leaving scope,
	// but only one instance can exist.
	UPtr<Type> uniquePtr = new<unique> Type(0);
	
	// Above is just syntactic sugar for...
	UPtr<Type> uniquePtr1 = UPtr<Type>(new<raw> Type(0));
	
	// Invalid - cannot copy unique pointers.
	UPtr<Type> uniquePtr2 = uniquePtr;
	
	// Allocated via garbage collection.
	Type * gcPtr = new<gc> Type(0);
	
	// Reference counted.
	RCPtr<Type> refCountedPtr = new<refcount> Type(0);
	
	// Can be copied, increasing ref count.
	RCPtr<Type> refCountedPtr1 = refCountedPtr;
	
	// Shared; could be GC or referencing counting.
	SPtr<Type> sharedPtr = new<shared> Type(0);
	
	// Can be copied.
	SPtr<Type> sharedPtr1 = sharedPtr;
	
	// Invalid - there is no default.
	auto defaultPtr = new Type(0);
}
\end{lstlisting}


\paragraph{}
Design decisions for new memory management methods were made in consideration of the fundamental aim to minimise the syntax required to instantiate an object on the heap, while maximising the available options for how to manage the memory. As the sample code shows, there is no default allocation method. The design perspective is that the lack of a default forces the programmer to consider how objects are to be allocated.

\paragraph{}
In contrast, C++ chooses to use a raw allocation as the basis of the new operator, however this is generally the most dangerous choice because exceptions can cause a delete statement to be missed and therefore memory is leaked; the other memory management methods are much safer.

\paragraph{}
Different memory management methods return different types that are responsible for managing the constraints of that allocation method. `UPtr', `RCPtr' and `SPtr' are types declared in the root namespace that are provided in the standard library.

\subsubsection{Unique Allocation}

\paragraph{}
While the other allocation methods are relatively complex, the `unique' method is trivial, and returns an object of type `UPtr', that is very similar to C++'s std::auto\_ptr. The key difference is that Loci provides much stronger rules relating to moving objects, so there are no problems with copying or assigning.

\paragraph{}
The details of moving vs copying is explained in great detail in the `LValues and RValues' section, however the short form description is that while auto\_ptrs have problems when they are copied or assigned\footnote{Since one auto\_ptr must take ownership of the pointer while another loses it, leading to potentially surprising results.}, Loci prevents the problem by disallowing copying (for these cases) and providing moving as a superior alternative.

\paragraph{}
Unique allocation should generally be used as much as possible as long as it doesn't restrict the developer, since it offers no overhead against a `raw' allocation, and yet will reliably recollect the memory and call the destructor.

\subsubsection{Reference Counting}

\paragraph{}
Reference counting provides a simple and deterministic way to release memory and call destructors when there are no remaining references to an object on the heap. Unlike garbage collection, which cannot ensure destructors are called, reference counting means destructors are called as soon as the last referring `RCPtr' instance is destroyed.

\paragraph{}
It does however restrict the developer to passing around `RCPtr' instances that are responsible for incrementing and decrementing the count. Another key limitation of reference counting is the failure to collect cycles; `RCWeakPtr' is provided with the usual `weak' semantics.

\subsubsection{Shared Allocation}

\paragraph{}
`SPtr' is provided to allow code\footnote{The imagined use case here is libraries, that are often dependent on the choices of the program that links them.} to take advantage of GC where it is available, but falls back to reference counting otherwise. This is typically best for immutable structures such as trees, and performance is usually better when using garbage collection.

\paragraph{}
This method of allocation is slightly more limited than using `gc' and does not expose a raw pointer that can be freely copied around the program, since this obviously wouldn't work with reference counting. Another restriction is that types must not have destructors, since GC cannot provide any sort of deterministic destruction. Finally, developers must be careful to avoid cycles.

\paragraph{}
In many ways, therefore, shared allocation suffers from the combined weaknesses of both GC and reference counting. It does, however, allow code that would hope to use garbage collection fall back to reference counting when necessary.

\subsubsection{Garbage Collection}

\paragraph{}
Garbage collection may also be available, using a conservative collector\footnote{Meaning that it doesn't need to move memory, which would be difficult to do at the level of C.}, and this is generally a good choice for allocating POD\footnote{Plain Old Data} types such as vectors, strings, trees etc. The availability of garbage collection depends on the standard library build type, so that some applications can choose to not use garbage collection; in such a case the developer will experience linker errors that will make the problem clear.

\paragraph{}
As with shared allocation, Loci will disallow the allocation of an object via garbage collection if it has a destructor. Finalisers could've been used to trigger destructor execution, but they are \emph{not deterministic}, and therefore any actions within the destructor cannot be guaranteed to be executed at a reasonable time\footnote{Unless other methods such as reference counting are used as well, however this defeats the purpose of garbage collection.}.

\paragraph{}
Typically types which might be garbage collected should not require a destructor, since most destructors are required for managing memory of the type's member variables, something that usually becomes unnecessary in the the presence of garbage collection.\footnote{Note that if a type's member variables have destructors, then the type itself will also have an auto-generated destructor which will call them, prohibiting its use with garbage collection.}

\paragraph{}
However, as with all rules, there may be reasonable exceptions, so a `forcegc' option is provided:


\begin{lstlisting}
class Type(int v){
	~Type(){
		//...
	}
};

void function(){
	// Fails to compile - 'Type' has destructor.
	Type * gcPtr = new<gc> Type(0);
	
	// Succeeds - but probably isn't wise, since 
	// the destructor will never be called.
	Type * gcPtr1 = new<forcegc> Type(0);
}
\end{lstlisting}


\clearpage

\subsection{L-values and R-values}

\paragraph{}
Loci uses the concept of L-values and R-values to provide a very simple way to implement move semantics. C++ supports copying as the primary operation for replicating values, however Loci instead uses move semantics by default. The latest version of C++ adds support for move operations, however this must be implemented on a per-type basis; Loci has no such complexities.

\paragraph{}
What this means for the programmer is that it is possible to easily prevent copies of class-types, because they are not copyable by default. There are many examples where such behaviour is desirable, including unique smart pointer types, socket types, mutex types, stream types etc.

\paragraph{}
L-values can be considered as actual storage locations, on either the heap or the stack. On the other hand, R-values are values `in-transit' and can be captured into an L-value. For example some variable `v' is an L-value, whereas the expression `v + 1' is an R-value.

\paragraph{}
This section also discusses `nullable objects', which have particularly expressive move semantics.

\paragraph{}
Here's an example of the move semantics in Loci:

\begin{lstlisting}
class SomeType(int * p){
	~SomeType(){
		// This destructor is only run
		// if the object is non-empty.
		delete<raw> @p;
	}
}

SomeType f(){
	// Return r-value.
	return SomeType(new<raw> 1);
}

SomeType function(){
	// Constructor called, and value moved into stack.
	// (Would be optimised to in-place construction on the stack.)
	SomeType a = SomeType(new<raw> 2);
	
	// Nullable type.
	SomeType? b = ?(SomeType(new<raw> 3));
	
	// Existing value in 'a' destroyed (destructor called),
	// value in 'b' moved into 'a', and 'b' is now left empty.
	a = b.extract();
	
	// Again, the value in 'a' is destroyed, and replaced
	// with the r-value result of calling function 'f'.
	a = f();
	
	// This will (typically) trigger an exception,
	// since the variable 'b' is empty.
	b->method();
	
	// R-Value returned from 'f' moved into empty lvalue 'b',
	// which then becomes non-empty.
	b = f();
	
	// This is only allowed if the compiler can statically
	// determine that the lvalue 'a' is being destroyed as
	// this point, and therefore can legitimately be cast
	// to an rvalue and returned instead.
	return a;
}
\end{lstlisting}


\subsubsection{Extracting L-Values}

\paragraph{}


\subsubsection{Nullable Types}

\paragraph{}
Loci has built-in support for `nullable' types, denoted by a question mark following the type name, which can be set to null, or compared with null, and also filled with non-null values of that type. Null objects can also be obtained by giving a nullable L-value a non-null value, and then extracting that value (with `extract').

\paragraph{}
The results of calling a method on a null object or casting it to a non-nullable type are defined to be throwing an exception of type `EmptyObjectException', but compilers are also allowed (and encouraged) to detect errors of this kind statically if possible and hence produce compile-time errors.

\paragraph{}
`extract' is the extraction operator, which causes the value within a nullable L-value to be extracted, turning it into a (nullable) R-value, and making the L-value empty. Extracting a nullable L-value that already has a null value is valid, and simply produces a null R-value\footnote{Therefore, extracted R-values are of `nullable' type themselves.}. For example:

\begin{lstlisting}
void f(){
	ObjectType? a = null;
	ObjectType? b = extract a;
	
	assert(a == null);
	assert(b == null);
}
\end{lstlisting}

\paragraph{}
Note that if an R-value is not captured into an L-value then it will be destroyed at the end of the statement, so extract can be used to destroy the value in a nullable L-value.

\paragraph{}
There is also the assignment statement of the form `v = expr;', in which the current value in L-value `v' is destroyed, and the R-value `expr' is moved into `v'. However, if there is no value currently in the lvalue prior to the assignment, then the destructor will not be called, as developers would expect.

\paragraph{}
Nullable types are built-in for a number of reasons, but most significantly because they depend on providing special behaviour the assignment statement. Unlike C++, Loci does not provide operator overloading for assignment, since the assignment operation behaviour is auto-generated outside of the object, and developers should find this behaviour much easier to handle.

\subsubsection{Non-nullable Types}

\paragraph{}
Without resorting to unsafe operators, non-nullable objects are considerably more limited than nullable objects. One limitation is that the extraction operator cannot be applied to non-nullable types, since doing so would put the objects in a undefined state and `extract' is a safe operator (unsafe operators are described later). Furthermore, non-nullable objects cannot be set or compared with null.

\paragraph{}
For this loss of functionality there is, however, a gain in speed since all checks are eliminated, and a reduction in size since nullable objects must have an extra field indicating whether they are null. Also, assignment is valid for non-nullable objects, and will always call the destructor of the L-value (since it cannot be null) and move the R-value into the L-value.

\subsubsection{Compared to C++}

\paragraph{}
This previous code showed the move semantics applied to a type `SomeType', for which the user has specified no special methods. In fact, `SomeType' is almost the complete implementation of `UPtr'\footnote{It is missing a trivial `Default' constructor implementation.}.

\paragraph{}
Additionally, the developer writing the class doesn't need to worry to about objects having a null state, since nullable types provide this, reliably and automatically producing the correct code for assignment and extraction.

\paragraph{}
In contract, the equivalent code in C++ would require manually defining a copy constructor (or a move constructor in the latest version) and an assignment method, which might look similar to the following:

\begin{lstlisting}
// This is C++ code!
class SomeType{
	public:
		SomeType(int * p){
			p_ = p;
		}
		
		SomeType(SomeType& t){
			p_ = t.p_;
			
			// Need to zero out state in previous copy.
			t.p_ = 0;
		}
		
		SomeType& operator=(const SomeType& t){
			// Avoid self-assignment.
			if(&t != this){
				// Destroy existing local state.
				delete p_;
				
				// Copy state.
				p_ = t.p_;
				
				// Zero state in 't'.
				t.p_ = 0;
			}
			return *this;
		}
		
		~SomeType(){
			// Check whether the object is empty.
			if(p_ == 0){
				delete p_;
			}
		}
	
	private:
		int * p_;
	
};
\end{lstlisting}


\paragraph{}
Clearly, C++ requires a large amount of code to produce similar semantics; Loci generates this code on behalf of the user, saving the programmer time in terms of both development and testing.

\clearpage

\subsection{Unsafe Move Operations}

\paragraph{}
The previous section discusses how to safely move objects, but there are cases where it's necessary to use unsafe operations. A good example is an array class in which, from the point of view of the client of the class, objects are never empty and safe move semantics are followed strictly.

\paragraph{}
However, internally an array class will allocate memory to store the objects, and after the initial allocation the objects within the array are in an `undefined state'\footnote{The Loci standard library memory allocator `std::alloc' initialises all allocated memory to zero by default, but objects are only in a defined state if their constructors have been run.}. This means that running a method on an object before it has been initialised properly can lead to undefined results that depend on the structure of the class and the method called.

\paragraph{}
After allocating the memory, the array will move R-values given to it into the memory allocated using an unsafe operator. Here's an example:

\begin{lstlisting}
// Admittedly this implementation is of low quality, but it is simple.
class ObjectArray(size_t size, ObjectType * memory){
	static Default(){
		return @(0, NULL);
	}
	
	void push_back(ObjectType object){
		@size++;
		const size_t lastIndex = @size - 1;
		@memory = reinterpret_cast<ObjectType *>(std::realloc(@memory, @size));
		
		// Note that the compiler must be able to
		// conclude that the L-value 'object' can
		// be safely automatically extracted.
		new<unsafe>(@memory[lastIndex]) object;
	}
	
	void pop_back(){
		const size_t lastIndex = @size - 1;
		@size--;
		delete<unsafe>(@memory[@lastIndex]);
	}
	
	// A non-standard method to demonstrate.
	ObjectType pop_back_and_return(){
		const size_t lastIndex = @size - 1;
		@size--;
		return extract<unsafe>(@memory[lastIndex]);
	}
}
\end{lstlisting}

\paragraph{}
As you can see, the `new', `delete' and `extract' operations all have unsafe forms.

\subsubsection{new}

\paragraph{}
The unsafe form of `new' moves the R-value given to it into the L-value reference given to it, but never calls the destructor on the reference, unlike the safe assignment operation `v = expr;'. It therefore has some similarity to a memcpy:

\begin{lstlisting}
void f(ObjectType object, ObjectType * memory){
	// This...
	new<unsafe>(@memory[0]) object;
	
	// ...would be equivalent to this...
	memcpy(&@memory[0], &object, sizeof(ObjectType));
	
	// ...except that the destructor for 'object'
	// will be run at the end of this function.
}
\end{lstlisting}

\paragraph{}
This example shows that using memcpy will fail to prevent local variables being destroyed; it would work correctly if copying between two allocated blocks of memory, assuming that objects owning those memory blocks knew to not call their destructors.

\subsubsection{delete}

\paragraph{}
The unsafe form of `delete' calls the destructor, providing the reference given to it as the `this' pointer that the destructor is intended to destroy. After the destructor has run, the memory is written to zeroes\footnote{Although it should be possible to disable this behaviour via compiler options if needed.}.

\paragraph{}
This operation returns no value (i.e. `void'), since the value at the reference given is now destroyed.

\subsubsection{extract}

\paragraph{}
`extract', in this case, is again very closely related to a memcpy in the opposite direction (from the heap to the stack), but memcpy would effectively have the opposite problem as with `new'; any stack objects used would have to be constructed, and copying into them would erase that previous instance without properly destroying it.

\paragraph{}
The behaviour is very simply: unsafe `extract' copies the data from the reference given to the stack as an R-value, and then writes zeroes to the memory block\footnote{Again, this behaviour can be disabled.}.

\subsubsection{Debugging}

\paragraph{}
Clearly code isn't written perfectly the first time, so it's likely that errors are made when using the unsafe operations. If the errors are not detected, they could lead to surprisingly results in the program or visible problems long after the actual error occurred.

\paragraph{}
Hence if a compiler is compiling in debug mode it should add an internal field to each object, that indicates whether that object contains a value (a zero value indicating it is empty); this enables the compiler to generate run-time checks to ensure that the unsafe operations are used correctly.

\clearpage

\subsection{Vector Types}

\paragraph{}
Loci supports SIMD operations directly through the use of vector types, allowing operations such as addition to be applied in parallel to a vector of integer or floating point values.


\begin{lstlisting}
void function(){
	int!4 a = {0, 1, 2, 3};
	int!4 b = {5, 6, 7, 8};
	int!4 c = a + b;
	
	// The resulting values.
	assert(c[0] == 5);
	assert(c[1] == 7);
	assert(c[2] == 9);
	assert(c[3] == 11);
}
\end{lstlisting}


\paragraph{}
The ternary operator also provides some interesting behaviour for vectorised types:


\begin{lstlisting}
void function(){
	int!4 a = {0, 1, 2, 3};
	int!4 b = {4, 5, 6, 7};
	bool!4 c = {true, false, true, false}
	
	int!4 d = c ? a : b;
	
	// The resulting values.
	assert(d[0] == 0);
	assert(d[1] == 5);
	assert(d[2] == 2);
	assert(d[3] == 7);
}
\end{lstlisting}

\clearpage

\subsection{Algebraic Datatypes}

\paragraph{}
Functional languages such as ML and Haskell provide algebraic data types as a mechanism for holding information, which may itself be of a number of different types. The following is a clear example of such a case, implemented in Loci:


\begin{lstlisting}
datatype BinaryTree{
	Leaf(int v){
		String toString(){
			return "Leaf(" + @v.toString() + ")";
		}
	}
	
	Node(BinaryTree& left, BinaryTree& right){
		String toString(){
			return "Node(" + @left.toString() +
				", " + @right.toString() + ")";
		}
	}
};
\end{lstlisting}


\paragraph{}
In this case, a binary tree element is either a Leaf which contains only an integer value, or a Node that contains two trees as its left and right children.

\paragraph{}
It is common to need to describe such types when handling lots of data (for example, building ASTs in a compiler), and also in general programming. Expressing similar structures in C or C++ requires the combination of enums, unions and structs, and furthermore unions and class types interact poorly in C++, as they do in Loci:

\begin{lstlisting}
// This is C++ code.

// Invalid - compiler can't know whether
// to call destructor for std::string.
// In Loci the problem is exactly the
// same, so objects cannot be in unions.
union UnionType{
	int i;
	std::string s;
};
\end{lstlisting}

\paragraph{}
Defining the structure isn't useful alone, and Loci expands on the existing `switch' statement to allow accessing and handling the contents of a data type.


\begin{lstlisting}
int getLeftMostValue(const BinaryTree& tree){
	switch(tree){
		case Leaf(int v){
			return v;
		}
		case Node(BinaryTree& left, _){
			return getLeftMostValue(left);
		}
	}
}
\end{lstlisting}

\paragraph{}
Note that the underscore character indicates an unused field of the data type.

\paragraph{}
This statement has some specific semantics:

\begin{enumerate}
\item The sub-types (in this case, `Leaf' and `Node') in the switch statement must be the complete set of sub-types within the parent type (`BinaryTree'); if any types are missed, compilation fails. However unspecified sub-types can be handled using a `default' entry.
\item Case statements can capture L-values within the data types. In the example the value in the leaf is captured so it can be printed to the command line.
\item No `break' statement is required to exit the switch, since this is almost always the desired behaviour and therefore requiring it is tedious for the programmer\footnote{Also, the behaviour is unintuitive for developers who are new to C-style languages.}. However, `continue' can be used to provide the behaviour of moving to the next case if desired.
\end{enumerate}

\clearpage

\subsection{Pattern Matching}

\paragraph{}
Algebraic datatypes are clearly a concept that has been adopted from functional languages such as ML and Haskell. Additionally, Loci supports extracting the members of these data types by binding them through pattern matching:

\begin{lstlisting}
data Pair(int l, int r);

Pair f(){
	return Pair(1, 2);
}

void g(){
	Pair(a, b) = f();
	//...
}
\end{lstlisting}

\paragraph{}
In this example, the types of binding variables `a' and `b' are not required, and are internally set to `auto' by the compiler, so it will then infer them.

\clearpage

\subsection{Operator Overloading}

\paragraph{}
Loci supports operator overloading as a useful way to provide a clean syntax for manipulating standard library or user defined types such as strings, vectors, matrices and arrays. Unlike C++, Loci uses normal function names to define methods that can be used in operator overloading:


\begin{lstlisting}
interface A{
	int compare(const A&) const;
	A add(const A&) const;
	A substract(const A&) const;
};

interface IntArray{
	int indexGet(size_t index);
	void indexSet(size_t index, int value);
};

void function(const A& a0, const A& a1, IntArray& array){
	// All following pairs are equivalent...
	bool compare = a0.compare(a1) < 0;
	bool compare = a0 < a1;
	
	A a2 = a0.opPlus(a1);
	A a2 = a0 + a1;
	
	A a3 = a0.opMinus(a1);
	A a3 = a0 - a1;
	
	array.indexSet(0, 5);
	array[0] = 5;
	
	int i = array.indexGet(0);
	int i = array[0];
}
\end{lstlisting}

\paragraph{}
Of particular interest is the `compare' method, which is an alternative to defining each of the comparison operators individually. Instead, developers just implement this single method which uses a negative, zero or positive integer to indicate (respectively) whether the left value is less than, equal to, or greater than the right value.

\paragraph{}
This functionality can avoid double comparisons (i.e. two applications of the less-than operator with left and right values swapped) inside container types (and other relevant functions/types). This is particularly beneficial for objects that may be expensive to compare, such as strings and memory blocks, but for which a single comparison can identify whether a value is less than, equal to, or greater than another value.

\clearpage

\subsection{Named Parameters}

\paragraph{}
There are often cases where it is difficult to ascertain the purpose of parameters passed to a function, or where it is difficult to remember the order of parameters to a function. For example:


\begin{lstlisting}
void function1(Renderer& renderer, Circle& circle){
	circle.draw(renderer, true);
}
\end{lstlisting}


\paragraph{}
In this case, the meaning of the second argument to the method, `true', is unclear. Similarly in the following case it is difficult to identify the order of parameters:


\begin{lstlisting}
void function2(){
	String haystack = "Hello world!";
	String needle = "world";
	
	// Is it...
	bool found = canFindString(needle, haystack);
	
	// Or...
	bool found = canFindString(haystack, needle);
}
\end{lstlisting}


\paragraph{}
Named parameters are a feature that aims to assist code documentation, as well as calling functions by the names of their parameters rather than the order, which in some cases is more meaningful. The two examples above can therefore be expressed clearly with this feature:


\begin{lstlisting}
void function1(Renderer& renderer, Circle& circle){
	circle.draw(renderer: renderer, drawOutline: true);
}

void function2(){
	bool found = canFindString(needle: "world", haystack: "Hello world!");
}
\end{lstlisting}


\paragraph{}
This is facilitated by the ability to type named function pointers, which can be implicitly cast to ordered function pointers:


\begin{lstlisting}
void f(int first, int second);

void function(){
	*(int)(int first, int second) namedFunctionPtr = f;
	*(int)(int, int) functionPtr = namedFunctionPtr;
	
	namedFunctionPtr(second: 1, first: 0);
	functionPtr(0, 1);
}
\end{lstlisting}


\clearpage

\subsection{Exceptions}

\paragraph{}
There has been (and is continuing to be) much debate on the relative merits of `checked' exceptions, `unchecked' exceptions and C-style error checking (along with other variants).

\paragraph{}
Based on an assessment of the implementations of exceptions in languages such as Java (checked), and C++ and C\# (unchecked), Loci uses unchecked exceptions as a standard method for functions to report some form of failure, since these trigger fewer architectural maintenance problems\footnote{Also, greater compatibility with C, since no extra information must be added to functions.}.


\begin{lstlisting}
interface AbstractException{
	std::string what() const;
}

class RealException(std::string what, int i){
	static Default(std::string what, int i){
		return @(what, i);
	}

	std::string what() const{
		return @what;
	}
}

void f(int i){
	if(i < 0){
		throw RealException("Function 'f' passed negative value.", i);
	}
}

String caller(){
	try{
		f(-1);
	}catch(const AbstractException& exception){
		std::string reason = exception.what();
		//...
	}
}
\end{lstlisting}


\paragraph{}
A stack trace is also constructed while these exceptions are in flight, and in the case that the exception reaches the top level of the program (i.e. the main function), the stack trace is printed along with the contents of the exception type.

\clearpage

\subsection{RTTI}

\paragraph{}
Loci provides far more comprehensive run-time type information than C++, giving extra functionality as well as efficiency to developers.

\subsubsection{is\_a}

\paragraph{}
This supports checking whether the actual type (which is known only at run-time, unless A is a class type) of a reference or pointer conforms to a given target type (B in this example).

\begin{lstlisting}
void f(A& object){
	if(is_a<B&>(object)){
		//...
	}
}
\end{lstlisting}

\paragraph{}
The performance for each case (depending on types of A and B) is:

\begin{itemize}
\item If A is a class type, and B is a class type, then the `is\_a' statement is resolved at compile-time (hence no run-time overhead).
\item If A is a class type, and B is an interface type, then the compiler can again resolve it at compile-time.
\item If A is an interface type, but B is a class type, the implementation for this is just a single comparison, so this is a very efficient way to check the type of an interface reference/pointer.
\item If A is an interface type, and B is an interface type, then this call involves a number of comparisons proportional to the number of methods in the larger interface, unless it can be determined at compile-time that there is a valid static cast from A to B.
\end{itemize}

\subsubsection{dynamic\_cast}

\paragraph{}
This operates just like C++:

\begin{lstlisting}
int f(A& object){
	B& castObject = dynamic_cast<B&>(object);
	return castObject.method();
}
\end{lstlisting}

\paragraph{}
This is effectively just the equivalent of calling is\_a to check the types are compatible, and then either allowing the reference/pointer to A to be treated as a reference/pointer to B, or throwing an exception in the case of a reference type, or returning NULL if it's a pointer.

\subsubsection{typeid}

\paragraph{}
This allows access to information about a type from a reference or pointer to an instance of it:

\begin{lstlisting}
void f(T& a, T& b){
	rtti::type_info typeInfo = typeid(a);
	
	// type_info structures can be compared,
	// but is_a is likely to be more efficient.
	if(typeInfo == typeid(b)){
		//...
	}
	
	// Get the type's name.
	string typeName = typeInfo.name;
	
	// Get the type's virtual table.
	void * vtable = typeInfo.vtable;
	
	// Get the type's size.
	size_t typeSize = typeInfo.size;
	
	for(size_t i = 0; i < typeInfo.methods.size(); i++){
		rtti::method_info methodInfo = typeInfo.methods[i];
		
		// Get method name.
		string methodName = methodInfo.name;
		
		// etc.
	}
}
\end{lstlisting}

\clearpage

\subsection{Faults}

\paragraph{}
Unlike C or C++ (but a lot like Java), Loci converts program errors such as SEGFAULTs into exceptions, to take advantage of the ability to catch exceptions and produce stack traces.


\begin{lstlisting}
int f(int * i){
	return *i;
}

int g(int[4] v, int i){
	return v[i];
}

void h(int v){
	assert(v >= 0);
}

void caller(){
	try{
		int i = f(null);
	}catch(NullPointerException e){
		//...
	}
	
	try{
		int[4] v = int[]{0, 1, 2, 3};
		int i = g(v, 100);
	}catch(VectorIndexOutOfBoundsException e){
		//...
	}
	
	try{
		h(-1);
	}catch(AssertionFailedException e){
		//...
	}
}
\end{lstlisting}


\clearpage

\subsection{Templates}

\paragraph{}
Loci implements templates, to provide parametric polymorphism, which is useful for defining the types of collections (along with many other things). The syntax is slightly simpler than C++:

\begin{lstlisting}
template <T>
class Class(T v){ }
\end{lstlisting}


\subsubsection{Type Properties}

\paragraph{}
Loci allows type properties to be expressed through the use of interfaces. For example:


\begin{lstlisting}
template <T>
interface Comparable{
	ConstructFromInt(int i);

	int compare(const T& v) const;
}

template <T: Comparable<T>>
class Class(T v0, T v1){
	static Default(T v0, T v1){
		return @(v0, v1);
	}

	bool lessThan() const{
		return @v0 < @v1;
	}
};
\end{lstlisting}


\paragraph{}
The interface, which is itself templated, requires that the parameter type `T' to class `Class' has the constructor and comparison operator specified. Note that constructors specified in interfaces can only be used in the context of template type parameters; it is meaningless\footnote{And will cause a compile-time error.} to attempt to construct an interface itself outside of a template.

\paragraph{}
Since primitive types are modelled as objects, even with their implementation being identical to C, they can also be used as template parameters:


\begin{lstlisting}
void function(){
	Class<int> cInt(1, 2);
	assert(cInt.lessThan());
}
\end{lstlisting}


\subsubsection{Instances}

\paragraph{}
The above code shows the creation of a class that has a type parameter `T'. In C++, instances of this class would be generated by the compiler for each type given as type `T'. So the following C++ code would generate four different classes in the object code produced by the compiler:


\begin{lstlisting}
Class<int> cInt;
Class<float> cFloat;

struct StructType{ int a; float b; };
Class<StructType> cS;

Class<StructType *> cSPtr;
\end{lstlisting}


\paragraph{}
In Loci the compiler only creates one instance of the class, which works correctly for all possible types for T. However this requires something similar to auto-boxing\footnote{Without the need to perform a heap allocation.} for primitive types, which is potentially slow, so it's possible to instruct the compiler to create particular instances of a templated class or function, using code such as the following\footnote{Which is essentially identical to the C++ syntax for explicit instantiation.}:


\begin{lstlisting}
template class Class<int>;
template class Class<float>;

struct StructType{ int a; float b; };
template class Class<StructType>;

template class Class<StructType *>;
\end{lstlisting}


\paragraph{}
This then creates the generic version of the class by default, but if the type is int, float, StructType or StructType*, the corresponding specialised (and therefore presumably faster) type is used. There's also a lot of capacity implementation-wise for compilers to improve the performance without breaking the functionality.

\clearpage

\subsection{Namespace Versions}

\paragraph{}
One of the primary goals of Loci is to be an excellent language for providing and using APIs, by ensuring that generated code is compatible across platforms and compilers (or if it is not compatible, fails with a clear error as early as possible).

\paragraph{}
Namespace versions are a fairly novel feature in Loci that aim to make it easy for developers to release multiple versions of their API, and to eliminate old versions and produce clear error messages for code that is still using now unavailable APIs.

\paragraph{}
For example, a library may change its method names, which would give errors indicating to the user of the library that they are calling a non-existent method. Ideally, though, the compiler (or linker) could produce an error indicating that the user of the library is using a non-existent API version, or even better, an outdated version.

\paragraph{}
Furthermore, there are other issues with contending versions of libraries, such as changes to internal implementations. Consider, for example, that a program `P' depends on a library `L'. Both P and L also depend on a library `S'.

\paragraph{}
If P and L use different versions of S (most likely in different shared libraries), they must not pass instances of classes from S between each other, in case the wrong methods are run on a particular instance. Even worse, one version of S may override the other in the dynamic symbol table.

\paragraph{}
Namespace versions offer a solution to these problems:

\begin{lstlisting}
namespace Library{
	class ObjectType{ };
}

namespace Library[a_version_string_100]{
	class ObjectType{ };
}
\end{lstlisting}

\paragraph{}
The first namespace declaration has an implicit version of the empty string, whereas the second has the explicit version ``a\_version\_string\_100". Client code can then use specific versions like so:

\begin{lstlisting}
Library::ObjectType f();

Library[a_version_string_100]::ObjectType g();
\end{lstlisting}

\paragraph{}
But this is slightly awkward, so a version other than the empty string can be selected to be default within a single module for a particular namespace:

\begin{lstlisting}
using Library[a_version_string_100]

// Now the empty string version has to be explicit.
Library[]::ObjectType f();

// Now equivalent to 'Library[a_version_string_100]::ObjectType g();'.
Library::ObjectType g();
\end{lstlisting}

\paragraph{}
The names of symbols within namespaces with different versions are clearly transformed/mangled to differ from each other, ensuring that multiple versions can co-exist.

\paragraph{}
Versions can also be removed:

\begin{lstlisting}
namespace Library[old_version] = null;
\end{lstlisting}

\paragraph{}
In this case, clients of the library will be informed that the version ``old\_version" has been removed.

\clearpage

\section{Standard Library}

\paragraph{}
In addition to the core language syntax and semantics, an important part of the overall system is the standard library, of which some parts are explained here.

\subsection{Strings}

\paragraph{}
Strings are used in Loci as the default way to handle character sequences, mostly replacing the `char *' string type as used in C and C++.

\subsubsection{Literals}

\paragraph{}
Loci breaks away from C by making string literals be of type `string', rather than type `const char *'. However C string literals can be declared by simply prefixing the double quotes with `C':


\begin{lstlisting}
void f(const char * cString){
	printf("%s", cString);
}

void function(){
	// Invalid - no implicit cast from String to char *.
	f("Hello world!");
	
	// Valid - literal prefixed with 'C' gives C string.
	f(C"Hello world!");
}
\end{lstlisting}


\subsubsection{I/O}

\paragraph{}
Input and output operations, such as that provided by C's \emph{printf} function, or by the stream types and shift operators in C++, are achieved in Loci by converting types to string format. Furthermore the language automatically generates methods for data types that convert them to a string, which contains the type's name and the string equivalents of its member variables.

\paragraph{}
Hence printing data is simple:

\begin{lstlisting}
data TwoInts(int a, int b);

void function(){
	auto t = TwoInts(1, 2);
	StdOut().writeLine("{%0}, {%1}, {%2}".format({1.0, "str", t}));
}
\end{lstlisting}

\paragraph{}
This prints:

\begin{verbatim}
1.0, str, TwoInts(1, 2)
\end{verbatim}

\subsection{Tuples}

\paragraph{}
Tuples are a useful way of passing around multiple values of different types together, particularly in the case of returning multiple values.

\begin{lstlisting}
(bool, int, float) f(){
	return (true, 1, 1.5);
}

void function(){
	(a, b, c) = f();
	//...
}
\end{lstlisting}

\paragraph{}
This example shows the creation of a 3-tuple, returning it from a function, and then retrieving the values within it by pattern matching on the type, so that variables `a', `b' and `c' are bound to the values in the tuple.

\subsection{Initializer Lists}

\paragraph{}


\cleardoublepage

\chapter{Implementation}

\paragraph{}
This section discusses the implementations of the features explained above; each feature was designed and considered on the basis on the ease and efficiency of its implementation. It is important that all compilers (and other implementation-related tools) behave exactly as specified in this section, except where it is noted otherwise, since this is vital to maintain compatibility.

\section{Name Mangling}

\paragraph{}
For the majority of functions and methods, Loci employs a very limited name mangling scheme, making Loci functions easy to call from C or other C-compatible languages. Here's a simple example:

\begin{lstlisting}
void outerFunction();

namespace OuterNamespace{
	void middleFunction();
	
	namespace InnerNamespace{
		void innerFunction();
	}
}
\end{lstlisting}

\paragraph{}
This code is exactly to the following C code \footnote{Which is also valid Loci code, again expressing exactly the same thing.}:

\begin{lstlisting}
void outerFunction();

void OuterNamespace__middleFunction();

void OuterNamespace__InnerNamespace__innerFunction();
\end{lstlisting}

\paragraph{}
Hence the mangling scheme for functions/methods within namespaces/classes, is to concatenate their names with the separator `\_\_'.

\section{Primitive Objects}

\paragraph{}
As described in detail in the design section, Loci provides functionality allowing 

\section{Empty Objects}

\paragraph{}
Empty objects are `just zeroes', whereas non-empty objects must have at least one non-zero byte. This is an important run-time property of objects, since it facilitates unrestricted\footnote{A compile-time `empty object' property would clearly need to be statically enforceable, and this requires certain limitations on the source and destination of move operations.} move operations.

\paragraph{}
In some cases, this means an extra bit\footnote{With padding this could become a cost of multiple bytes.} is required to indicate that an object is non-empty. For example:

\begin{lstlisting}
class Example(int i) {
	static Default(int i) {
		return @(i);
	}
	
	~{
		printf("Value is %d.\n", @i);
	}
}
\end{lstlisting}

\paragraph{}
In this case the compiler is forced to generate a struct like the following:

\begin{lstlisting}
struct Example_impl {
	bool isEmpty;
	int i;
};
\end{lstlisting}

\paragraph{}
The `isEmpty' field would be updated by moves accordingly; the destructor code would then look something like:

\begin{lstlisting}
void destructor(Example_impl* object) {
	if (object->isEmpty) return;
	// User destructor code.
	printf("Value is %d.\n", object->i);
}
\end{lstlisting}

\paragraph{}
Note that the empty/non-empty distinction is only made for the benefit of destructors, to ensure that they are only called when the object is non-empty, and so code must not rely on the distinction in general. For example:

\begin{lstlisting}
class Example(int i) {
	static Default(int i) {
		return @(i);
	}
}
\end{lstlisting}

\paragraph{}
In contrast to the above, the underlying struct for this class will \emph{not} have an extra field, since the destructor is empty. Note that member variable objects must maintain their own distinction for empty vs non-empty as needed, since it's possible for an object to be non-empty while one of its member variables is empty.

\subsection{Reducing the overhead}

\paragraph{}
Fortunately the compiler can eliminate the `isEmpty' field altogether in most cases. The extra field is required if all of the following conditions hold:

\begin{enumerate}
\item There is a custom destructor (i.e. one specified by the programmer).
\item All-zeroes is believed to be a reachable state for all member variables (e.g. a reference can never be NULL, so the compiler could take advantage of that).
\item The destructor is presumed to perform `observable' behaviour in an `all-zero' state (e.g. a `unique' smart pointer destructor does nothing if the pointer is set to NULL).
\end{enumerate}

\paragraph{}
Hence it's possible for the compiler to eliminate the extra field where it can determine that one of the above properties does not hold. There is also likely to be a language mechanism added to allow users to specify a custom predicate for determining whether the destructor should be run, to handle cases that the compiler can't statically verify.

\section{Class Parameters}

\paragraph{}


\section{Virtual Method Calls}

\paragraph{}
Class vtables are only generated when a class reference is cast to an interface type reference, and compilers must generate a vtable for each such cast, meaning that there may be multiple vtables per class, and a vtable will often not contain pointers to all the methods of the class. Vtable pointers are not stored within an object, but are carried around as part of an interface type reference, and this means an interface type reference\footnote{Pointers do not support polymorphism, and an interface type pointer is illegal. Hence this only affects references.} is actually two pointers: one to the object, and one to the vtable.

\paragraph{}
A class vtable contains around\footnote{To be decided...} 20 function pointers to its methods. The compiler will create a hash (via SHA-256) for each mangled method name from the target interface type, and truncate that hash to the first 8 hex digits (i.e. first 8 4-bit sequences), giving a 32 bit value. It's important that these values do not clash, and compilers must check this for each interface type.

\paragraph{}
These hashes are then calculated modulo the vtable size (number of function pointers), to give offsets into the vtable. Unlike the original 32-bit hashes, these offsets can clash.

\subsection{Calling a method}

\paragraph{}
Code generated to perform virtual method calls then simply needs to do the following:

\begin{enumerate}
\item Obtain the vtable pointer.
\item Load the method's function pointer from its offset in the vtable.
\item Set the hidden parameter (platform dependent, but usually a 32 bit register\footnote{On x86, eax should be used.}) to the 32-bit hash value.
\item Call the function pointer with its arguments.
\end{enumerate}

\subsection{Conflict Resolution}

\paragraph{}
Clearly there may be conflicts in the vtable, in which multiple methods share the same offset. In this case, the compiler must generate a conflict resolution stub, which is an assembly routine that uses the hidden parameter to determine which method is intended to be called. A stub may look like the following:

\begin{lstlisting}
conflict_resolution_stub:
	cmp eax, <METHOD 1 HASH>
	jne .method_2
.method_1:
	jmp method_1
.method_2:
	jmp method_2
\end{lstlisting}

\paragraph{}
A conflict resolution stub must not affect the stack or any of the callee-save registers. It should pass control to the method, which will then return directly to the original caller.

\subsection{Code example}

\paragraph{}
The virtual method call process described roughly corresponds to the following C code:

\begin{lstlisting}
struct VTable {
	void* methodPointers[20];
};

struct ObjectType;

struct InterfaceRef {
	VTable* vtable;
	ObjectType* object;
};

// E.g. method takes one 'int' parameter and returns 'void'.
typedef void (*ExampleMethod)(ObjectType*, int);

void callFunc(InterfaceRef interfaceRef){
	VTable* vtable = interfaceRef.vtable;	
	
	// Get method pointer.
	// E.g. '2' is the offset in this case.
	ExampleMethod methodPtr = (ExampleMethod) vtable->methodPointers[2];
	
	// E.g. '42424242' is the hash in this case.
	asm volatile ("movl $42424242, %%eax"
		:
		:
		: "%eax");
	
	methodPtr(interfaceRef.object);
}
\end{lstlisting}

\subsection{Performance}

\paragraph{}
The implementation described has many advantages versus competing approaches, such as provided by C++'s virtual tables. It provides the semantic behaviour described previously in this document, but also minimises the overhead of a virtual method call to be negligible compared to other approaches and languages.

\paragraph{}
As mentioned above, the vtable is generated for a class when it is cast to an interface type, and that the vtable only includes the methods of the interface. Since the implementation uses a hash table, this is likely to significantly reduce the number of collisions in most cases, which will usually mean eliminating conflict resolution stubs, or in some cases simply shortening them. This therefore reduces the indirection, comparisons and branching required so that in the vast majority of cases setting the hidden parameter is the only overhead.

\paragraph{}
This design also differs from C++ in that vtable pointers are not stored in objects, but are part of an interface type reference. This decision is particularly appropriate to the language, since Loci doesn't require classes to explicitly implement interfaces, and would otherwise therefore need vtable pointers in every object (in case the object is used polymorphically).

\paragraph{}
There's also the potentially much greater benefit that a memory access can be avoided, assuming the vtable pointer can be held in a register, or that at least a heap memory access to the object to retrieve the vtable pointer is likely to be replaced with a stack memory access, which may reduce the chances of a cache miss. The drawback is that an interface type reference is two pointers in size (doubling the cost of a move), but this is a very minor overhead and only affects polymorphic references.

\paragraph{}
On modern machines, the call/jump instruction is the most expensive operation, generally due to the need to flush the instruction pipeline. This is of course unavoidable in dynamic dispatch (i.e. where optimisations fail to convert calls to static dispatch), so applies to typical dynamic dispatch mechanisms in other languages.

\subsection{Birthday Problem}

\paragraph{}
Assessing the value of this dynamic dispatch scheme is best achieved by relating it to the birthday problem.

\subsubsection{The problem}

\paragraph{}
If there is a set of $n$ individuals, with birthdays that are distributed with an independent and uniform probabability through a year of 365 days, the probability $P_{u}(n)$ that they all have unique birthdays is, approximately:

$$P_{u}(n) = (\frac{364}{365})^{\frac{n(n - 1)}{2}}$$

\paragraph{}
So, the probability $P_{c}(n)$ that there is at least one birthday clash is $1 - P_{u}(n)$:

$$P_{c}(n) = 1 - \frac{364}{365}^{\frac{n(n - 1)}{2}}$$

\paragraph{}
The essence of this `problem' is that relatively small values of $n$ can have a surprisingly high probability $P_{c}(n)$ of clashes. Relating this to the hash table dynamic dispatch, performance is improved by minimising clashes between the indexes of the vtable function pointers in the tables.

\subsubsection{Hash Table Collisions}

\paragraph{}
Using the above, the probability of collision $p_{c}(n)$ for a hash table of size $n$ is:

$$p_{c}(n) = 1 − \frac{19}{20}^\frac{n(n − 1)}{2}$$

\paragraph{}
This gives the following:

\paragraph{}
0: 0\%.
1: 0\%.
2: 5\%.
3: 14.3\%.
4: 26.5\%.
5: 40.1\%.
6: 53.7\%.
7: 65.9\%.
8: 76.2\%.

\paragraph{}
Estimates of likely interface sizes depend on the code and the way it's written. However, a reasonable guideline (and one that suggests good design) is to generally have at most 4 methods per interface, so collisions are expected to occur for only about a quarter of hash tables generated. Hence in around 75\% of cases this dispatch mechanism is almost equivalent to C++ virtual dispatch, the only difference being the need for the caller to set the hidden parameter.

\subsubsection{Hash Value Collisions}

\paragraph{}
As explained above, the compiler computes a 32-bit hash value for each method in an interface. If there is a collision between the values, the compiler cannot generate a conflict resolution stub to disambiguate the methods and therefore the compiler must inform the user via an error that the interface is invalid. This must occur extremely rarely, since this means an implementation detail affecting a high level design decision.

\paragraph{}
Again, the calculation of probability is:

$$p_{c}(n) = 1 − \frac{2^32 - 1}{2^32}^\frac{n(n − 1)}{2}$$

\paragraph{}
Which gives:

\paragraph{}
0: 0\%.
1: 0\%.
2: 0.00000002\%.
3: 0.00000007\%.
4: 0.00000014\%.
5: 0.00000023\%.
6: 0.00000035\%.
7: 0.00000049\%.
8: 0.00000065\%.

\paragraph{}
Given a presumed average of 4 methods per interface, the calculation to identify $m$, the expected number of interfaces that have no hash value collisions before one does have a collision, is:

$$p_{u}(4) = 1 - p_{c}(4)$$
$$p_{u}(4)^m = 0.5$$
$$ln (p_{u}(4)^m) = ln 0.5$$
$$m ln p_{u}(4) = ln 0.5$$
$$m = \frac{ln 0.5}{ln p_{u}(4)}$$

\paragraph{}
Which gives:

$$m = 4.95 x 10^8$$

\paragraph{}
In other words, the probability of at least one hash value collision is 50\% for around half a billion interfaces generated.

\cleardoublepage

\chapter{Justification}

\section{Class Inheritance}

\paragraph{}
Loci doesn't support inheritance between classes, in which one class `B' inherits the member variables and methods from another class `A', and usually instances of B can be cast to A (generally via a pointer or reference). Note that the latter functionality is polymorphism, and is supported by Loci's interfaces.

\paragraph{}
C++ supports both single inheritance and multiple inheritance, and even virtual inheritance for resolving the diamond problem. Most other languages, including Java, C\# and D, support only single inheritance, which helps to alleviate the problems with multiple inheritance.

\paragraph{}
However Loci doesn't support inheritance, as a matter of design, instead providing composition as superior method of code reuse. Inheritance has a number of flaws, including the fragile superclass problem, violating encapsulation, increasing coupling between classes and early binding of the implementation of the subclass to that of the superclass.

\paragraph{}
On the other hand, composition is a very powerful mechanism to allow one class to use the functionality of another without relying on the internal implementation of the superclass.

\paragraph{}
While inheritance (in particular tall class hierarchies) encourage monolothic design, a combination of composition and interfaces facilitates modular designs consisting of many small single-purpose classes. Furthermore, classes can modify their internal behaviour, while maintaining a stable API, without breaking code that uses them, which clearly goes a long way towards satisfying Loci's key design goals.

\paragraph{}
The decision not to include inheritance was not made based on whether developers might or might not misuse it\footnote{For example, Java decided to throw out operator overloading on this basis, which turned out to be harmful to those developers who understood how to use the feature correctly.}, but rather the impact it has on the language, both in terms of the semantics and the actual implementation.

\paragraph{}
Any feature added must be integrated into the language, so that it is defined how it interacts with other parts of the language, and may imply a significant amount of effort on the part of the implementor(s).

\cleardoublepage

\chapter{Other Languages}

\paragraph{}
While the rest of this document briefly compares Loci to other programming languages, this section goes into more detail. Some languages are named and considered individually, since they are closely related to the target area of Loci, while more `distant' languages are considered in groups.

\section{C}

\paragraph{}


\section{C++}

\paragraph{}


\cleardoublepage

\chapter{Additional Topics}

\section{Concurrency and Parallelism}

\paragraph{}
Recently there have been many discussions about taking advantage of the increasing amounts of parallelism that is becoming possible through improvements to hardware. Much focus is directed towards programming languages and how they might facilitate taking advantage of these improvements.

\paragraph{}
In particular, a compiler can struggle to optimise normal code in a language such as in C into machine code that can be effectively parallelised by the hardware. Vector types and operations, supported in Loci and explained above, are a good method to achieve performance benefits from new architectures within the context of a single processor.

\paragraph{}
However, there is of course no silver bullet to achieving multi-processor performance benefits; developers must still be responsible for profiling their own code and restructuring it so that it can be run in parallel.

\paragraph{}
Typically, gains are made either in low-level routines (e.g. image processing) via parallelising instructions, or via high-level restructuring. In the former case, the language provides vector operations that need to be used correctly; in the latter it is up to the developer to implement their high-level design, though the standard library should assist this.

\paragraph{}
Some forms of parallelism, such as threads, can be dangerous since it is difficult for the programmer to analyse how parallel threads might interact. Processes, on the other hand, are an excellent way to achieve parallelism since memory is no longer shared, but may suffer from a lack of system support or high IPC overhead.

\paragraph{}
Again, it is up to the developer to make and implement these decisions, so like any other language Loci cannot provide significant `automatic' parallelisation of code without substantial cooperation from the developer of the code.

\section{Classes vs Algebraic Datatypes}

\paragraph{}


\section{Garbage Collection}

\paragraph{}
Many languages now include garbage collection, including high-level scripting languages such as Python as well as slightly lower-level languages such as Java and C\#. C and C++ have not adopted garbage collection as a core language feature, focusing instead on manual memory management and smart pointers; D is a very low-level language that does include garbage collection.

\paragraph{}
Loci combines garbage collection with the memory management approaches taken by C++, so that developers can choose the allocation method that is appropriate to their application. The aim is to make it possible to use manual memory management, smart pointers and deterministic destruction alongside garbage collected data.

\paragraph{}
Again, this is divided between `system' modules and PODs, in which modules benefit greatly from stack allocation or heap allocation with management by smart pointers, whereas PODs benefit from being collected automatically.

\paragraph{}
In the case of module objects, it is typical to only have a single non-copyable instance of the object, which needs deterministic destruction so it can release its non-memory resources, and therefore tends to be ideally suited to being placed on the stack.

\paragraph{}
If a module object is allocation on the heap, a unique smart pointer (i.e. where there is one owner) is almost always desired to manage it. If there need to be multiple owners, a reference counted smart pointer can be used.

\paragraph{}
PODs on the other hand are typically immutable (or at least, rarely modified) and certainly copyable objects, but for which it is ideal to avoid copying. If these objects are allocated on the heap, it can be difficult to manage them because many objects simultaneously own them. Garbage collection is the ideal solution in this case.

\paragraph{}
A good example of effective use of garbage collection are ropes used in the implementation of Loci's strings. These are binary trees, of which the nodes are concatenations of their children, and the leaves refer to positions within blocks.

\paragraph{}
Pointers to the nodes, the leaves and the blocks they refer to can be freely copied, eliminating the performance cost of copying, with the knowledge that the garbage collector will reclaim the memory when necessary. Ropes thereby achieve logarithmic complexity (as opposed to linear) for concatenation, insertion and deletion of strings.

\paragraph{}
This can be achieved by reference counting, but the increments and decrements to the counters are costly compared to the simple pointer copies allowed by garbage collection.

\end{document}













