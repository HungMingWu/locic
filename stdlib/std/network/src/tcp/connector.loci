import int std_tcp_connect_v4(uint32_t address, uint16_t port) noexcept;

export std.network 0.1.0 {
	
	namespace std {
		
		namespace tcp {
			
			class connector (int handle) {
				static create(endpoint dest) {
					switch (dest.address) {
						case ip::address_v4_(uint32_t value) {
							return @(std_tcp_connect_v4(value, dest.port));
						}
						case ip::address_v6_(uint64_t low, uint64_t high) {
							// TODO!
							unreachable;
						}
					}
				}
				
				~ {
					if (@handle >= 0) {
						std_tcp_close(@handle);
					}
				}
				
				int _release() noexcept {
					assert @handle >= 0;
					const int tmp = @handle;
					@handle = -1;
					return tmp;
				}
				
				event::source event_source() const noexcept {
					assert @handle >= 0;
					const bool waitForRead = false;
					const bool waitForWrite = true;
					return event::source._handle(@handle, waitForRead, waitForWrite);
				}
				
				bool ready() const {
					assert @handle >= 0;
					return self.event_source().poll();
				}
			}
			
			stream connector_wait(connector conn) {
				conn.event_source().wait();
				assert conn.ready();
				return connector_get(move conn);
			}
			
			stream connector_get(connector conn) {
				assert conn.ready();
				const int handle = conn._release();
				return stream._create(handle);
			}
			
		}
		
	}
	
}

