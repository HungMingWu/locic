// Workaround for the fact locic doesn't
// yet support opaque types.
struct sfContextSettings { };
struct sfRenderWindow { };
struct sfRenderStates { };

void printf(const char* text, ...);

sfRenderWindow* sfRenderWindow_create(sfVideoMode mode, const char* title, int style, const sfContextSettings* settings);

void sfRenderWindow_destroy(sfRenderWindow* renderWindow);

void sfRenderWindow_clear(sfRenderWindow* renderWindow, sfColor color);

void sfRenderWindow_setFramerateLimit(sfRenderWindow* renderWindow, int limit);

void sfRenderWindow_display(sfRenderWindow* renderWindow);

void sfRenderWindow_drawCircleShape(sfRenderWindow* renderWindow, const sfCircleShape* const object, const sfRenderStates* const states);

uint8_t sfWindow_isOpen(const sfRenderWindow* const window);

uint8_t sfWindow_pollEvent(sfRenderWindow* window, sfEvent* event);

void sfWindow_close(sfRenderWindow* window);

namespace sf {
	
	class RenderWindow(sfRenderWindow* window) {
		static Create (VideoMode videoMode, const char* title) {
			// TitleBar (1) + Resize (2) + Close (4)
			// (And 8 would give FullScreen...)
			final int style = 7;
			
			return @(sfRenderWindow_create(sfVideoMode(videoMode.width, videoMode.height, videoMode.bitsPerPixel), title, style, null));
		}
		
		~ {
			sfRenderWindow_destroy(@window);
		}
		
		bool isOpen() const {
			return sfWindow_isOpen(@window) != 0u;
		}
		
		void close() {
			sfWindow_close(@window);
		}
		
		bool pollEvent(sfEvent* event) {
			return sfWindow_pollEvent(@window, event) != 0u;
		}
		
		void clear(Color color) {
			sfRenderWindow_clear(@window, sfColor(color.r, color.g, color.b, color.a));
		}
		
		void setFramerateLimit(int limit) {
			sfRenderWindow_setFramerateLimit(@window, limit);
		}
		
		void display() {
			sfRenderWindow_display(@window);
		}
		
		void drawCircle(const CircleShape& shape) {
			sfRenderWindow_drawCircleShape(@window, shape.raw(), null);
		}
		
		const sfRenderWindow* const windowPointer() const {
			return @window;
		}
	}
	
}


