// Program entry point.

double Random(){
	// return double(rand()) / (double(RAND_MAX) + 1.0);
	// TODO!!!
	return 0.0;
}

double SRandom(){
	return 2.0 * Random() - 1.0;
}

void initializeBoard(CR::Board& board){
	for (auto x: std::counter<size_t>(1u, 0u, board.size().width)) {
		for (auto y: std::counter<size_t>(1u, 0u, board.size().height)) {
			board[CR::Position(x, y)] = CR::Empty();
		}
	}
	
	const bool position = (Random() > 0.5);
	
	final auto width = board.size().width;
	final auto height = board.size().height;

	// Add initial positions.
	board[CR::Position(width / 2u - 1u, height / 2u - 1u)] = position ? CR::Red() : CR::Blue();
	board[CR::Position(width / 2u, height / 2u)]           = position ? CR::Red() : CR::Blue();
	board[CR::Position(width / 2u - 1u, height / 2u)]      = position ? CR::Blue() : CR::Red();
	board[CR::Position(width / 2u, height / 2u - 1u)]      = position ? CR::Blue() : CR::Red();
}

// Entry point.
int main() {
	final auto boardSize = CR::BoardSize(8u, 8u);
	final auto initialColour = Random() > 0.5 ? CR::Red() : CR::Blue();
	final auto board = CR::Board(boardSize, initialColour);
	
	CR::Value lastWinner = CR::Red();
	
	initializeBoard(board);
	
	auto renderWindow = sf::RenderWindow(sf::VideoMode(800u, 800u, 32u), C"Chain Reversi");
	renderWindow.setFramerateLimit(25);
	
	// Whether a game is currently active.
	bool playing = true;
	
	// Whether p0 (false) or p1 (true) is the current player.
	bool currentPlayer = Random() > 0.5;
	
	auto player0 = CR::HumanPlayer(renderWindow);
	auto player1 = CR::AIPlayer(renderWindow);
	
	auto clock = sf::Clock();
	
	final auto font = sf::Font(C"Data/font.ttf");
	
	while (renderWindow.isOpen()) {
		auto event = sfEvent(0, 0u);
		
		while (renderWindow.pollEvent(&event)) {
			if (event.type == 0) {
				renderWindow.close();
			}
		}
		
		if (playing) {
			if (!board.isComplete()) {
				if (!currentPlayer) {
					auto optionalPosition = player0.performMove(board);
					
					switch (optionalPosition) {
						case CR::Some(CR::Position position) {
							board.placeMove(position);
							currentPlayer = true;
						}
						case CR::None() { }
					}
				} else {
					auto optionalPosition = player1.performMove(board);
					
					switch (optionalPosition) {
						case CR::Some(CR::Position position) {
							board.placeMove(position);
							currentPlayer = false;
						}
						case CR::None() { }
					}
				}
			} else {
				// Indicate the result to players.
				if (!currentPlayer) {
					player0.gameOver(false);
					player1.gameOver(true);
				} else {
					
					player0.gameOver(true);
					player1.gameOver(false);
				}
				
				playing = false;
				lastWinner = board.opponent();
			}
			clock.restart();
		} else if(clock.getElapsedTime().asSeconds() > 5.0f) {
			playing = true;
			initializeBoard(board);
		}
		
		// Clear screen to black.
		renderWindow.clear(sf::Color(0u, 0u, 0u, 255u));
		
		for (auto x: std::counter<size_t>(1u, 0u, board.size().width)) {
			for (auto y: std::counter<size_t>(1u, 0u, board.size().height)) {
				auto backgroundCircle = sf::CircleShape();
				backgroundCircle.setRadius(45.0f);
				backgroundCircle.setFillColor(sf::Color(20u, 20u, 20u, 255u));
				backgroundCircle.setPosition(sf::Vector2f(x.toFloat() * 100.0f + 5.0f, y.toFloat() * 100.0f + 5.0f));
				renderWindow.drawCircle(backgroundCircle);
				
				final const auto position = CR::Position(x, y);
				
				auto foregroundCircle = sf::CircleShape();
				foregroundCircle.setRadius(40.0f);
				
				switch (board[position]) {
					case CR::Red() {
						if (playing) {
							foregroundCircle.setFillColor(sf::Color(255u, 0u, 0u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(150u, 0u, 0u, 255u));
						}
					}
					case CR::Blue() {
						if (playing) {
							foregroundCircle.setFillColor(sf::Color(0u, 0u, 255u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(0u, 0u, 150u, 255u));
						}
					}
					case CR::Empty() {
						if (board.isValid(position)) {
							foregroundCircle.setFillColor(sf::Color(70u, 70u, 70u, 255u));
						} else {
							foregroundCircle.setFillColor(sf::Color(30u, 30u, 30u, 255u));
						}
					}
				}
				
				foregroundCircle.setPosition(sf::Vector2f(x.toFloat() * 100.0f + 10.0f, y.toFloat() * 100.0f + 10.0f));
				renderWindow.drawCircle(foregroundCircle);
			}
		}
		
		if (!playing) {
			auto winnerText = sf::Text();
			winnerText.setFont(font);
			winnerText.setCharacterSize(100u);
			winnerText.setColor(sf::Color(255u, 255u, 255u, 255u));
			
			switch (lastWinner) {
				case CR::Red() {
					winnerText.setString(C"Red wins!");
				}
				case CR::Blue() {
					winnerText.setString(C"Blue wins!");
				}
				case CR::Empty() {
				}
			}
			
			final const auto textLocalRect = winnerText.getLocalBounds();
			winnerText.setOrigin(sf::Vector2f(textLocalRect.topLeft.x + textLocalRect.size.x / 2.0f,
					textLocalRect.topLeft.y + textLocalRect.size.y / 2.0f));
			
			winnerText.setPosition(sf::Vector2f(400.0f, 400.0f));
			
			/*final const auto textGlobalRect = winnerText.getGlobalBounds();
			
			const float extraWidth = textGlobalRect.size.x * 0.5f;
			const float extraHeight = textGlobalRect.size.y * 0.5f;
			
			sf::RectangleShape winnerTextBackground(sf::Vector2f(textGlobalRect.size.x + extraWidth, textGlobalRect.size.y + extraHeight));
			winnerTextBackground.setPosition(textGlobalRect.topLeft.x - (extraWidth/2.0f), textGlobalRect.topLeft.y - (extraHeight/2.0f));
			winnerTextBackground.setFillColor(sf::Color(0u, 0u, 0u, 200u));
			renderWindow.draw(winnerTextBackground);*/
			
			renderWindow.drawText(winnerText);
		}
		
		renderWindow.display();
	}
	
	return 0;
}

