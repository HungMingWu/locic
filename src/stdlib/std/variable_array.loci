template <typename T, typename Array: array<T>>
class array_range(Array& array, size_t start, size_t end) {
	static default(Array& array){
		return @(array, 0, array.size());
	}
	
	bool empty() {
		return @start == @end;
	}
	
	void advanceFront() {
		assert(!self.empty());
		@start++;
	}
	
	lval<T> front() {
		assert(!self.empty());
		return lval @array[@start];
	}
	
	void advanceBack() {
		assert(!self.empty());
		@end--;
	}
	
	lval<T> back() {
		assert(!empty());
		return lval @array[@end - 1];
	}
	
	bool invariant() {
		return @start <= @end && (!self.empty() implies @end > 0);
	}
	
}

template <typename T>
class variable_array(size_t size, size_t capacity, T* data) {
	static default() {
		@(0, 0, null);
	}
	
	static literal_array(const forward_range<T>& range) {
		auto array = variable_array<T>();
		for(value in range){
			array.push_back(move(value));
		}
		return array;
	}
	
	void reserve(size_t size) {
		if(size <= @capacity) return;
		T* newData = reinterpret_cast<T*>(calloc(size, sizeof(T)));
		for(i in 0 .. @size){
			newData[i] := move @data[i];
		}
		@data = newData;
		@capacity = size;
	}
	
	size_t capacity() {
		return @capacity;
	}
	
	void resize(size_t size) {
		reserve(size);
		for(i in size .. @size){
			@data[i] := void;
		}
		@size = size;
	}
	
	size_t size() {
		return @size;
	}
	
	lval<T> indexAt(size_t index) {
		assert(index < @size);
		return lval @data[index];
	}
	
	array_range<T, this_type> range() {
		return array_range<T, this_type>(@data, 0, @size);
	}
	
	variable_array<T> copy() <T: copyable<T>> {
		auto array = variable_array<T>();
		array.resize(@size);
		for(i in 0 .. @size){
			array[i] := self[i].copy();
		}
		return array;
	}
}


