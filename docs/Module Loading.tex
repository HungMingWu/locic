\documentclass{article}

\title{Loci Module Loading}
\author{Stephen Cross}
\date{}

\begin{document}
\maketitle

\section{Introduction}

\paragraph{}
Loci provides the ability for external classes to be used without knowledge of their size at compile-time (or even link-time), since they can be loaded in at run-time through shared libraries. Instances of these classes can be stored on the stack, which is more efficient than existing cross-API-boundary solutions that require placing instances of unknown classes on the heap. However, it makes the computation of sizes and offsets within objects more complex.

\paragraph{}
For example, consider the following example:

\begin{verbatim}
class A(B b, C c){}

class B(D d){}

class C(int i){}

class D(int i){}
\end{verbatim}

\paragraph{}
Given that these classes are all in separate modules that are not defined until run-time, their sizes can only be determined at run-time. The problem is that A cannot access its member C without knowledge of the size of B, since that determines the offset. Furthermore, when A is allocated it determines its size by querying B, which then queries D, and then by querying D. With enough levels, this can become inefficient.

\paragraph{}
Hence a possible solution is to cache values via a conditional that checks if the value has already been computed and therefore doesn't re-compute it. This is better, but evaluating the conditionals themselves is expensive considering that it will be performed so often. There are also some problematic cases to consider:

\begin{verbatim}
class A(B b){}

class B(C d){}

class C(A a){}
\end{verbatim}

\paragraph{}
Here there is a cycle of dependencies that should result in an error.

\paragraph{}
Fortunately, there is a better solution available. Due to the need to support C++'s static constructors and destructors, it is possible to have a function run when a module is first loaded. LLVM provides this, for example, via `\emph{llvm.global\_ctors}' and `\emph{llvm.global\_dtors}'. Unfortunately, testing proves it is not possible to rely on the priority values to correctly order running the functions within a single module, but this doesn't present a significant difficulty in this case, since modules may be loaded in an undesirable order anyway.

\paragraph{}
The solution is therefore to have a function run when each compiled Loci module is loaded, which will determine the sizes of each of the classes and give an error if there are cycles of dependencies within classes.

\section{Class Record}

\paragraph{}
In order to facilitate this solution, a structure called the 'class record' must be defined for representing the current state of the process of determining the sizes and offsets. Consider this example:

\begin{verbatim}
class A(B b){}

class B(C d){}

class C(int i){}
\end{verbatim}

\paragraph{}
A problem is that the modules holding these classes can be loaded in any order. In the ordering C, B, A, each simply does one step to calculate its own size. However, in the ordering A, B, C, no work is done until C is loaded, at which point the sizes of A and B must be determined. Whichever order the modules are loaded, an equivalent amount of computation is performed, but how it is spread may vary.

\paragraph{}
The class record holds the following information in its `header':

\begin{itemize}
\item The total size of the class, of if not yet determined, its known minimum size (i.e. based on primitive members such as integers).
\item The size of the class record, in terms of the number of entries.
\item A pointer to another class record, which must be updated once the size of this class has been determined.
\item The offset of the entry of the 
\end{itemize}

\paragraph{}
Hence, in C code, the header looks like the following:

\begin{verbatim}
struct ClassSizeInfo{
    size_t classSize;
    size_t offsets[];
};
\end{verbatim}

\paragraph{}
It also holds information in each entry, which corresponds to a member of the class that has an unknown size at compile-time. This is simply the offset of the member class within its parent and a pointer to its class record:

\begin{verbatim}
struct ClassRecordEntryPointer{
    struct ClassRecord * nextRecord;
    size_t nextOffset;
};
\end{verbatim}

\begin{verbatim}
struct ClassRecordEntry{
    struct ClassRecord * memberRecord;
    size_t memberClassSize;
    struct ClassRecordEntryPointer nextPtr;
};
\end{verbatim}

\paragraph{}
This leads to the definition of `ClassRecord':

\begin{verbatim}
struct ClassRecord{
    struct ClassSizeInfo * sizeInfo;
    size_t emptySlotCount, numEntries;
    struct ClassRecordEntryPointer parentList;
    struct ClassRecordEntry entries[];
};
\end{verbatim}

\paragraph{}
The intial values are specified similar to the following:

\begin{verbatim}
struct ClassSizeInfo classSizeInfo = {CLASS_MIN_SIZE, {0, 0}};

struct ClassRecord classRecord = {&classSizeInfo, 2, 2,
                                  {NULL, 0},
                                  {{&memberAClassRecord, NULL, 0},
                                   {&memberBClassRecord, NULL, 0}}};
\end{verbatim}

\paragraph{}
Where `CLASS\_MIN\_SIZE' is a constant that would be replaced by the total size of the members of the class that had a known size at compile-time (and hence are its minimum size). This value must be at least sizeof(void *), since it includes a pointer to the vtable.

\section{Resolution}

\paragraph{}
The resolution procedure uses the following algorithm:

\begin{verbatim}
// Fill parents in with this class' size, now that it has been computed.
void fillParents(struct ClassRecord * classRecord){
    struct ClassRecord * nextRecord = classRecord->parentList.nextRecord;
    size_t nextOffset = classRecord->parentList.nextOffset;
    while(nextRecord != NULL){
    	nextParentClassRecord->entries[nextOffset].memberClassSize = classRecord->sizeInfo->classSize;
        nextParentClassRecord->emptySlotCount--;
        
        if(nextParentClassRecord->emptySlotCount == 0){
            // All member sizes now known => calculate offsets.
            size_t offset = nextRecord->sizeInfo->classSize;
            for(size_t i = 0; i < nextRecord->numEntries; i++){
                nextRecord->sizeInfo->offsets[i] = offset;
                offset += nextRecord->entries[i].memberClassSize;
            }
            nextRecord->sizeInfo->classSize = offset;
            
            fillParents(nextRecord);
        }
        
        struct ClassRecordPointer * nextPtr = &(nextRecord->entries[nextOffset].nextPtr);
        nextRecord = nextPtr->nextRecord;
        nextOffset = nextPtr->nextOffset;
    }
}

void resolve(struct ClassRecord * classRecord){
    for(size_t i = 0; i < classRecord->numEntries; i++){
        if(classRecord->entries[i].memberRecord->emptySlotCount == 0){
            classRecord->entries[i].memberClassSize = classRecord->entries[i].memberRecord->sizeInfo->classSize;
            classRecord->emptySlotCount--;
        }
    }
    
    if(classRecord->emptySlotCount == 0){
        fillParents(classRecord);
    }else{
        for(size_t i = 0; i < classRecord->numEntries; i++){
            if(classRecord->entries[i].memberClassSize == 0){
            	classRecord->entries[i].nextPtr.nextRecord = classRecord->entries[i].memberRecord->
                classRecord->entries[i].memberClassSize = classRecord->entries[i].memberRecord->sizeInfo->classSize;
                classRecord->emptySlotCount--;
            }
        }
    }
    ClassRecordEntry * entry = &(classRecord->entries[0]);
    while(true){
    	struct ClassRecordEntry * entry = &(classRecord->entries[i]);
        struct ClassRecord * memberClassRecord = entry->memberClassRecord;
        if(memberClassRecord->){
            offset += memberClassRecord->header.classSize;
        }
        
        entry->memberClassOffset = offset;
        
        if(entry->memberClassRecord == NULL){
            break;
        }else{
            entry++;
        }
    }
    
    if(isComplete(classRecord)){
        fillRecords(classRecord);
    }
}
\end{verbatim}

\end{document}













