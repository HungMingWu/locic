\documentclass{article}

\title{Loci Module Loading}
\author{Stephen Cross}
\date{}

\begin{document}
\maketitle

\section{Introduction}

\paragraph{}
Loci provides the ability for external classes to be used without knowledge of their size at compile-time (or even link-time), since they can be loaded in at run-time through shared libraries. Instances of these classes can be stored on the stack, which is more efficient than existing cross-API-boundary solutions that require placing instances of unknown classes on the heap. However, it makes the computation of sizes and offsets within objects more complex.

\paragraph{}
For example, consider the following example:

\begin{verbatim}
class A(B b, C c){}

class B(D d){}

class C(int i){}

class D(int i){}
\end{verbatim}

\paragraph{}
Given that these classes are all in separate modules that are not defined until run-time, their sizes can only be determined at run-time. The problem is that A cannot access its member C without knowledge of the size of B, since that determines the offset. Furthermore, when A is allocated it determines its size by querying B, which then queries D, and then by querying D. With enough levels, this can become inefficient.

\paragraph{}
Hence a possible solution is to cache values via a conditional that checks if the value has already been computed and therefore doesn't re-compute it. This is better, but evaluating the conditionals themselves is expensive considering that it will be performed so often. There are also some problematic cases to consider:

\begin{verbatim}
class A(B b){}

class B(C d){}

class C(A a){}
\end{verbatim}

\paragraph{}
Here there is a cycle of dependencies that should result in an error.

\paragraph{}
Fortunately, there is a better solution available. Due to the need to support C++'s static constructors and destructors, it is possible to have a function run when a module is first loaded. LLVM provides this, for example, via `\emph{llvm.global\_ctors}' and `\emph{llvm.global\_dtors}'. Unfortunately, testing proves it is not possible to rely on the priority values to correctly order running the functions within a single module, but this doesn't present a significant difficulty in this case, since modules may be loaded in an undesirable order anyway.

\paragraph{}
The solution is therefore to have a function run when each compiled Loci module is loaded, which will determine the sizes of each of the classes and give an error if there are cycles of dependencies within classes.

\section{Class Record}

\paragraph{}
In order to facilitate this solution, a structure called the 'class record' must be defined for representing the current state of the process of determining the sizes and offsets. Consider this example:

\begin{verbatim}
class A(B b){}

class B(C d){}

class C(int i){}
\end{verbatim}

\paragraph{}
A problem is that the modules holding these classes can be loaded in any order. In the ordering C, B, A, each simply does one step to calculate its own size. However, in the ordering A, B, C, no work is done until C is loaded, at which point the sizes of A and B must be determined. Whichever order the modules are loaded, an equivalent amount of computation is performed, but how it is spread may vary.

\paragraph{}
The class record holds the following information in its `header':

\begin{itemize}
\item The total size of the class, of if not yet determined, its known minimum size (i.e. based on primitive members such as integers).
\item A pointer to another class record, which must be updated once the size of this class has been determined.
\end{itemize}

\paragraph{}
Hence, in C code, the header looks like the following:

\begin{verbatim}
struct ClassRecordHeader{
    size_t classSize;
    struct ClassRecord * nextRecord;
};
\end{verbatim}

\paragraph{}
It also holds information in each entry, which corresponds to a member of the class that has an unknown size at compile-time. This is simply the offset of the member class within its parent and a pointer to its class record:

\begin{verbatim}
struct ClassRecordEntry{
    size_t memberClassOffset;
    struct ClassRecord * memberClassRecord;
};
\end{verbatim}

\paragraph{}
This leads to the definition of `ClassRecord':

\begin{verbatim}
struct ClassRecord{
    struct ClassRecordHeader header;
    struct ClassRecordEntry entries[];
};
\end{verbatim}

\paragraph{}
The intial values are specified similar to the following (note that the entry array is null-terminated):

\begin{verbatim}
struct ClassRecord classRecord = {{CLASS_MIN_SIZE, NULL},
                                  {{CLASS_MIN_SIZE, &memberAClassRecord},
                                   {CLASS_MIN_SIZE, &memberBClassRecord},
                                   {CLASS_MIN_SIZE, NULL}}};
\end{verbatim}

\paragraph{}
Where `CLASS\_MIN\_SIZE' is a constant that would be replaced by the total size of the members of the class that had a known size at compile-time (and hence are its minimum size). This value must be at least sizeof(void *), since it includes a pointer to the vtable.

\section{Resolution}

\paragraph{}
The resolution procedure uses the following algorithm:

\begin{verbatim}
int isComplete(struct ClassRecord * classRecord){
    size_t prevValue = 0;
    ClassRecordEntry * entry = &(classRecord->entries[0]);
    while(true){
    	if(entry->memberClassOffset == prevValue){
            return 0;
        }else if(entry->memberClassRecord == NULL){
            return 1;
        }else{
            prevValue = classRecord->entries[i].memberClassOffset;
            entry++;
        }
    }
}

void fillRecords(struct ClassRecord * classRecord){
    struct ClassRecord * nextClassRecord = classRecord->header.nextRecord;
    while(nextClassRecord != NULL){
        ClassRecordEntry * entry = &(nextClassRecord->entries[0]);
        int addOffset = 0;
        while(true){
            if(entry->memberClassRecord == classRecord){
                addOffset = 1;
            }else if(addOffset){
                entry->memberClassOffset += classRecord->header.classSize;
            }
            
            if(entry->memberClassRecord == NULL){
                break;
            }else{
                entry++;
            }
        }
        nextClassRecord->header.classSize += classRecord->header.classSize;
        if(isComplete(nextClassRecord)){
            fillRecords(nextClassRecord);
        }
        nextClassRecord = nextClassRecord->header.nextRecord;
    }
}

void resolve(struct ClassRecord * classRecord){
    size_t offset = classRecord->header.classSize;
    ClassRecordEntry * entry = &(classRecord->entries[0]);
    while(true){
    	struct ClassRecordEntry * entry = &(classRecord->entries[i]);
        struct ClassRecord * memberClassRecord = entry->memberClassRecord;
        if(isComplete(memberClassRecord)){
            offset += memberClassRecord->header.classSize;
        }
        
        entry->memberClassOffset = offset;
        
        if(entry->memberClassRecord == NULL){
            break;
        }else{
            entry++;
        }
    }
    
    if(isComplete(classRecord)){
        fillRecords(classRecord);
    }
}
\end{verbatim}

\end{document}













