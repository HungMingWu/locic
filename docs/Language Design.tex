\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{caption}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subfig}

\lstset{basicstyle=\ttfamily\scriptsize,
	language=C++,
	keywordstyle=\textbf,
	frame=single,
	breaklines=true,
	tabsize=2,
	showstringspaces=false,
	float=t}

\lstloadlanguages{
         C,
         C++,
         Java
 }


\title{Loci Programming Language}
\author{Stephen Cross}

\raggedbottom						   % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}	   % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}	% adjust line spacing to make
										% more readable

\begin{document}

%%%%%%%%%%%%% TITLE PAGE %%%%%%%%%%%%%
\pagestyle{empty}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Loci Programming Language} \\
\vspace*{5mm}
Stephen Cross \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%% TABLE OF CONTENTS %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\tableofcontents

\listoffigures

\cleardoublepage

%%%%%%%%%%%%% CONTENT %%%%%%%%%%%%%

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

\paragraph{}
The C programming language is a widely used programming language and compilers are available for almost all architectures. Furthermore, many programming languages provide the means to call into/out-of C, facilitating inter-operation of different programming languages with C as a `bridge'. While technically useful, the C programming language is often perceived as lacking sufficiently powerful abstractions to construct large and complex systems. For this reason, languages such as C++, Objective C and D were invented to provide abstractions on top of the language.

\paragraph{}
Unfortunately, these languages have significant problems. For example, C++ and D place undue attention to compile-time functionality that serves to complicate the source code. Interestingly, Objective-C shifts the vast majority of the burden to run-time, and hence uses weak typing. Preference of programming languages is certainly based on the opinion of individual programmers, however languages also face general criticism. In particular, C++ attracts criticism due to its large set of features and rules that ultimately combine to produce complex semantics. Equally, however, programmers support the combination of powerful features as found in a multi-paradigm language such as C++.

\paragraph{}
The design of languages that are both simple and powerful is difficult, and popular existing programming languages represent a variety of reasonable solutions. A number of newer languages have emerged that operate at a `higher level' than languages such as C and C++, of which examples are Java and C\#. Typically, these languages use primitives and pointers as fundamental types, deploy some form of garbage collection, use classes as their fundamental data structures and provide the means to construct inheritance hierarchies. There is a disputed performance cost to using these languages over lower level languages, which is generally found to be small and hence arguably insignificant.

\paragraph{}
However, these languages also suffer significant problems: there are no deterministic destruction routines (which must be provided by the programmer through constructs such as try...finally), the languages have extensive dependencies on the large and complex environment that supports them and they lack direct access to lower level routines typically available in C. Furthermore, despite aims to remain simple, many of these languages have become increasingly complex as it is discovered the initial design was insufficiently powerful. Special cases (e.g. Java's + operator for strings) further serve to complicate the languages.

\section{Aims}

\paragraph{}
This document therefore describes and rationalises the design of the Loci programming language, which aims to provide strong compatibility with C, while adding useful efficient high level abstractions, and without the complexities that arise in C++.

\paragraph{}
Loci should satisfy the following (quite vague) goals:

\begin{itemize}
\item Modular - The language must help to produce programs in which the basic problem is split into distinct components, which can be easily re-combined to solve other problems.
\item Portable - The language should be independent of any specific machine architecture or operating system, such that programs can be ported easily.
\item Compatible - The language must be compatible with existing languages/standards so that it can make use of existing services.
\item Simple - The language must remove all unnecessary complexity and maximize developer efficiency so that time can be best spent solving the problem at hand. It is important to reduce the learning curve to remove any barriers preventing new developers from embracing the language.
\item Clean - The language must help to produce clean and consistent applications which can be easily read and understood. It is important that when one developer sees code written by another developer it is easy for them to understand it, in order to aid collaboration.
\item Small - The language must produce resulting code that is small and free of dependencies except those specified in the program and understood to the developer, such that distribution is simple and fast.
\item Fast - The language must provide good performance, to maximise its utility.
\end{itemize}

\section{Name}

\paragraph{}
While it has been suggested that Loci could stand for `Loci: objects, classes and interfaces', this is not the intended understanding because the language is much more than just being object orientated\footnote{Like C++, Loci is a multi-paradigm language.}. Instead, the name reflects the following definitions of its singular form:

\begin{quotation}
\emph{locus} - the set of all points or lines that satisfy or are determined by specific conditions
\end{quotation}
\begin{quotation}
\emph{locus} - A place or locality, especially a centre of activity
\end{quotation}

\section{Specific Goals}

\paragraph{}
Establishing this basis for Loci, it is possible to elaborate more specific goals for the language:

\begin{itemize}
\item \textbf{Provide stable interfaces between modules.} A change in one module should not require a module that depends on it to be re-compiled, unless there are changes that break the API. In particular, classes in libraries can change their internal structure (i.e. their member variables) without requiring re-compilation of clients of the library.
\item \textbf{Follow a standard binary interface for each platform.} Modules compiled by different compilers must work together. Loci creates standard C functions with fixed naming rules and calling conventions.
\item \textbf{Fast compile times.} This is vital to maximise productivity. Loci files are effectively isolated from each other, such that they can be tokenized and parsed in parallel, and then the resulting structures can be used to resolve and verify dependencies. Effectively parallelising builds for other languages is often significantly more complex.
\item \textbf{Minimal syntactic complexity.} For example, header guards are required in C to prevent a header from being included twice. In Loci all files are equal and are only analyzed once, so there is no need to add any sort of guards. Furthermore the Loci compiler uses multiple passes so type declarations/definitions do not have to appear before their use.
\item \textbf{Minimal semantic complexity.} Loci avoids language features (or combinations of language features) that affect the readability and predictability of code. For example, Loci does not support function or method overloading, since these can easily increase the complexity of the language with little to no added benefit.
\item \textbf{Provide a powerful polymorphism mechanism.} Loci provides interfaces, that are effectively equivalent to C++ pure virtual classes with a virtual destructor, or Java interfaces. Loci uses structural typing, so casts are allowed from classes to interfaces if the class provides all the methods required by the interface.
\end{itemize}

\cleardoublepage

\chapter{Design}

\paragraph{}
Loci is very closely related to C in both syntax and semantics, with the ability to call C functions (and be called from C) easily and to handle C types. Numerous ideas from languages such as C++, Java, Objective C, ML and Python are also used\footnote{Although in varying amounts; the language certainly pulls more ideas from C++ than any other language.} to develop the features and abstractions that Loci provides on top of the basic functionality of C.

\paragraph{}
A primary concern for the language design is closely resembling the `look and feel' of languages such as C and C++, with the intention that developers familiar with those languages should be able to easily get started in Loci. Syntactic or semantic divergences from existing languages are justified in this document.

\paragraph{}
Loci emphasises providing choice for the programmer, in the form of features that are each suited for particular purposes, where such features interact well with the rest of the language. A good example is algebraic data types, which are well suited to expressing data such as ASTs\footnote{Abstract Syntax Trees, which are constructed in a compiler front-end and approximately express the structure of the input source code.}.

\paragraph{}
However, as well as using ideas from many languages, Loci also specifically rejects some features, such as method/function overloading, class inheritance and weak typing\footnote{Specifically, a large set of legal implicit casts. For example, in C, it is valid to implicitly cast from `void *' to `int *'.}. Each of the features left out are considered at least unnecessary and potentially harmful, and interact poorly with the surrounding environment.

\paragraph{}
In addition, Loci modifies well known features to make them easier to use, to help the programmer avoid common pitfalls and as an attempt to fix the flaws in some programming languages that are now evident in hindsight. The language also attempts to help programmers verify code correctness and to make code reasonably self-documenting.

\paragraph{}
This section explains and justifies some of the design decisions made within the language; the following section then shows how these features are implemented. Each design decision was made with a good understanding of how it would be implemented, in particular to minimise the compiler complexity\footnote{And correspondingly, the time taken for compilation.}, code dependencies and code size, and to maximise the performance.

\section{Language}

\subsection{C}

\paragraph{}
As mentioned previously, Loci is highly related and compatible with C. It therefore supports:

\begin{itemize}
\item Primitive types (e.g. `int').
\item Pointer types.
\item Struct types.
\item Enum types.
\item Union types.
\item Function pointer types.
\item C's calling convention, so it can call and be called from C functions.
\end{itemize}

\subsubsection{Syntax}

\paragraph{}
There are however, some minor syntactic changes. For example, like C++, struct type names do not need need to be prefixed with the struct name except when they are defined:

\begin{lstlisting}
struct A{
	int v;
};

void function(){
	// Valid, but `struct' keyword is unnecessary.
	struct A a;
	
	// Valid, and same as above.
	A a;
}
\end{lstlisting}

\paragraph{}
This syntactic change applies similarly for enum and union types. The intention, clearly, is to reduce the verbosity of the code and therefore the burden on the programmer to write it.

\paragraph{}
Casts also use a different syntax:

\begin{lstlisting}
void function(){
	float pi = 3.141592654;
	
	// Invalid.
	int intPi = (int) pi;
	
	// Valid.
	int intPi = cast<int>(pi);
}
\end{lstlisting}

\paragraph{}
The new syntax is much clearer, helping readers to understand exactly what value is being cast, since the precedence of the type cast may not be obvious\footnote{Few programmers remember all (or close to all) of their language's operator precedences.} Consider this example:

\begin{lstlisting}
void function(Type * ptr, Type::*function()){
	// As one expects...
	int i = (int) ptr->member;
	
	// ...is equivalent to this.
	int i = ((int) ptr->member);
	
	// But this...
	int i = (int) ptr->member + 1;
	
	// ...is equivalent to this.
	int i = ((int) ptr->member) + 1;
	
	// And this (C++ code)...
	int i = (int) ptr->*function();
	
	// ...would be equivalent to this.
	int i = ((int) ptr)->*function();
	
	// (Which is of course broken.)
	
}
\end{lstlisting}

\subsubsection{Semantics}

\paragraph{}
There are also some minor semantic changes, in particular to the available implicit casts:


\begin{lstlisting}
void function(){
	float pi = 3.141592654f;
	
	// Invalid - no implicit cast.
	int intPi = pi;
	
	// Valid - explicit cast is allowed.
	int intPi = cast<int>(pi);
	
	// Invalid - no implicit cast from 'void *' to 'int *'.
	int * intPtr = malloc(sizeof(int));
	
	// Valid.
	int * intPtr = pointer_cast<int *>(malloc(sizeof(int)));
	
	
}
\end{lstlisting}


\paragraph{}
In this case, the intention is to make it clear to a reader when values are being cast to fundamentally different types (such as an integer and a floating point value). The `cast' operator supports legal implicit and explicit casts, whereas the `pointer\_cast' operator allows casts between pointers whose target types (i.e. the type being pointed-to) are different.

\clearpage

\subsection{Type Syntax}

\paragraph{}
Loci strictly follows the following structure for all typed variables declarations:


\begin{lstlisting}
[TYPE] [NAME]
\end{lstlisting}


\paragraph{}
This differs significantly from C, in which types and names can overlap in confusing ways, such as in function pointer types:


\begin{lstlisting}
void (*f)(); // C
void (*)() f; // Loci

int (*f)(); // C
int (*)() f; // Loci

int (*f)(int, int); // C
int (*)(int, int) f; // Loci
\end{lstlisting}


\paragraph{}
Similarly, typedefs are much clearer in Loci:


\begin{lstlisting}
typedef A (*B)(C c); // C
typedef A (*)(C) B; // Loci
\end{lstlisting}


\clearpage

\subsection{References}

\paragraph{}
Loci references are in almost all ways identical to C++ references. The example below shows the syntax and semantics if the reader is unfamiliar:

\begin{lstlisting}
void function(int data, int * pointer){
	{
		// Invalid - no implicit cast from
		// pointer type to reference type.
		int& reference = pointer;
	}
	
	{
		// Valid - using dereference operator
		// to cast from pointer to reference.
		int& reference = *pointer;
	}
	
	{
		// Invalid - again, no implicit cast
		// from pointer type to reference type.
		int& reference = &data;
	}
	
	{
		// Valid - making reference of 'data'.
		int& reference = data;
	
		// Valid - updating lvalue referred to
		// by 'reference', which in this case
		// would be 'data'...
		reference = 1;
		
		// ...so this is equivalent.
		data = 1;
		
		// Invalid - type 'int' has no overload for
		// the dereference operator.
		*reference = 2;
		
		// Valid - copying reference lvalue to rvalue,
		// adding 5, and placing it into lvalue 'newData'.
		int newData = reference + 5;
	}
	
	{
		// Invalid - can't convert rvalue to non-const
		// lvalue reference.
		int& reference = 1;
	}
	
	{	
		// Valid - uses a special cast from rvalue to const
		// lvalue reference...
		const int& reference = 5;
		
		// ...which is basically equivalent to this.
		const int __unnamed_value = 5;
		const int& reference = __unamed_value;
	}
}
\end{lstlisting}

\clearpage

\subsection{Classes}

\paragraph{}
The ability to create and manipulate objects, which are instances of a class, provides a useful way to encapsulate a set of behaviour around a particular data type, and maintaining the necessary invariants needed by that type. Therefore Loci, like many other languages, includes support for object oriented programming.

\subsubsection{Definitions}

\paragraph{}
Here's an example of a Loci class definition:


\begin{lstlisting}
class Bucket(bool b, int value){
	bool containsValue() const{
		return @b;
	}
	
	void placeValue(int value){
		assert(!@b);
		@value = value;
	}
	
	int getValue() const{
		assert(@b);
		return @value;
	}
}
\end{lstlisting}


\paragraph{}
The organisation is somewhat different to many languages, and member variables are defined within the parentheses after the class name. The methods, constructors and destructors then appear within the braces that follow.

\paragraph{}
Another detail is that instance member variables are referred to using the @ symbol, which provides a clean alternative to the various C++ conventions for naming such variables\footnote{For example: `mValue' or `value\_'.}; such variables are also accessible through the use of the `this' pointer:


\begin{lstlisting}
	//...
	bool containsValue() const{
		return this->b;
	}
	//...
\end{lstlisting}


\subsubsection{Constructors}

\paragraph{}
The above example shows a class with no constructor, however there is an automatically generated constructor named `Default', so that the above is equivalent to:


\begin{lstlisting}
class Bucket(bool b, int value){
	static Default(bool b, int value){
		return @(b, value);
	}

	...
}

void function(){
	// Equivalent ways to call the default constructor.
	Bucket bucket = Bucket(true, 1);
	Bucket bucket = Bucket::Default(true, 1);
}
\end{lstlisting}


\paragraph{}
Here the @ symbol being called is the `internal constructor', and performs the actual construction of the class type\footnote{Which means, the process of filling the fields of the struct underlying the class with the values given to it.}. This system is intended as a superior alternative to initialization lists in C++ and Java. Here's an example of a C++ initialization list:


\begin{lstlisting}
// This is C++ code.
class Bucket{
	public:
		Bucket(bool b, int value)
			: b_(b), value_(value){ }
};
\end{lstlisting}


\paragraph{}
Avoiding initialization lists makes it easy to express complex logic in constructors, such as loops:


\begin{lstlisting}
class SomeClass(int value0, int value1){
	static Factorial(int n){
		int r = 1;
		for(int i = 2; i < n; i++){
			r *= i;
		}
		return @(r, r * r);
	}
};

void function(){
	SomeClass c = SomeClass::Factorial(10);
}
\end{lstlisting}


\paragraph{}
Other named constructors can also be created:


\begin{lstlisting}
class Bucket(bool b, int value){
	...
	
	static WithNoValue(){
		return @(false, 0);
	}
	
	static WithZeroValue(){
		return @(true, 0);
	}

	...
}

void function(){
	Bucket emptyBucket = Bucket::WithNoValue();
	Bucket zeroBucket = Bucket::WithZeroValue();
}
\end{lstlisting}


\subsubsection{Declarations}

\paragraph{}
Perhaps most interesting is the ability to declare classes. Unlike C++ where this is commonly needed, declarations typically won't be needed within a shared codebase, because Loci can find the class definitions and produce their corresponding declarations automatically.

\paragraph{}
Additionally, Loci uses multiple passes so that there is no need to define types or functions before they are used, so there is no need to declare a class which is later defined in the same code base, something that is common in C and C++.

\paragraph{}
However, if a class is to be used across an API boundary\footnote{For example, the class is defined inside a static library, and a program uses the declaration to create instances of the class and call its methods.} then declarations should be used.

\paragraph{}
Here's a declaration of the Bucket class:


\begin{lstlisting}
class Bucket{
	static Default(int v);

	bool containsValue() const;
	
	void placeValue(int value);
	
	int getValue() const;
}
\end{lstlisting}


\paragraph{}
Clearly, the class method implementations have been removed, however the member variables have also been removed. This is because, unlike C++, class declarations in Loci do \emph{not} need to include the types (or names) of the member variables.

\paragraph{}
From a design perspective, this prevents the need to use forward struct declarations (or similar) and heap allocations that are needed in C and C++, and is part of fulfilling Loci's goal to be an excellent language for defining, implementing and using APIs. Therefore clients of a library do not need to be recompiled when a class in the library changes its member variables, since this is private information.

\paragraph{}
Also note that the auto-generated default constructor has to be specified explicitly here, since users of the class declaration have no knowledge of the types (or number, or order) of the member variables and therefore cannot know the type of the constructor.

\clearpage

\subsection{Null}

\paragraph{}
C expresses the concept of null through the use of the NULL constant, which is of type `void *'. C++ expresses null through an implicit cast from the integer value 0 to a null pointer, or in the latest version through a specially defined constant of a special type.

\paragraph{}
Loci adds null in a similar way to the latest version of C++, where there is a universal constant `null' of type `null\_t', which has an implicit cast to any pointer type:


\begin{lstlisting}
void function(){
	// All valid.
	null_t n = null;
	int * i = n;
	int * j = null;
	float * f = null;
}
\end{lstlisting}


\paragraph{}
Loci also supports defining empty objects through an implicit cast from `null\_t' to any `nullable' object type. Hence it is possible to do:


\begin{lstlisting}
void function(){
	ObjectType? object = null;
	
	// This will throw an exception.
	object.method();
	
	// Also supports primitive types.
	int? i = null;
}
\end{lstlisting}


\paragraph{}
Note that the Bucket type is not a pointer type, but is indeed a value type. The syntax and semantics for handling empty objects is explained in the `L-values and R-values' section.

\clearpage

\subsection{Primitive Objects}

\paragraph{}
The C standard library provides some basic mathematical routines to perform simple operations:


\begin{lstlisting}
void function(){
	float a = -1.5;
	float b = fabs(a);
	float c = floor(b);
	float d = sqrt(c);
}
\end{lstlisting}


\paragraph{}
Through the compatibility with C, these routines clearly remain available in Loci. However, Loci `revamps' the primitive types to be object types:


\begin{lstlisting}
void function(){
	float a = -1.5;
	float b = a.abs();
	float c = b.floor();
	float d = c.sqrt();
}
\end{lstlisting}


\paragraph{}
These modifications turn the primitive types into object types from the developer's perspective, even though the implementation is identical to C and there is therefore no performance penalty.

\paragraph{}
Syntactically, the change is quite significant, but there is also a considerable semantic difference since primitive references can be interface types, and primitives can satisfy template requirements that are based on their methods. Unlike C++, and surprisingly even Java, Loci provides a neat way to integrate primitives with other object types.

\clearpage

\subsection{Interfaces}

\paragraph{}
Java provides the concept of interfaces as equivalent to a pure virtual class in C++. This means that interfaces declare the methods that an implementing class must support, without providing any implementation of those methods. As compared to inheritance of classes, this is an ideal way to model the API of a class.

\paragraph{}
Loci uses, and extends, this concept by using interfaces as the basis for structural typing. This means that classes don't need to explicitly specify that they implement an interface, but if they have all the methods specified in the interface with the correct types and names then references to the class can be implicitly cast to references to the interface.

\paragraph{}
For example:


\begin{lstlisting}
class Bucket{
	static Default(int v);
	bool containsValue() const;
	void placeValue(int value);
	int getValue() const;
}

interface ValueHolder{
	bool containsValue() const;
	int getValue() const;
}

int f(const ValueHolder& valueHolder){
	return valueHolder.getValue();
}

void function(){
	Bucket bucket = Bucket(2);
	int value = f(bucket);
}
\end{lstlisting}


\paragraph{}
This clearly diverges from the approach taken by many languages, which is to requires classes to specify the interfaces they implement. However, the increased flexibility of this method allows interfaces to be defined \emph{after} classes have been defined, which would allow code like the following:


\begin{lstlisting}
interface LengthValue{
	size_t length() const;
}

size_t f(const LengthValue& lv){
	return lv.length();
}

void function(){
	String string = "Hello world!";
	size_t length = f(string);
}
\end{lstlisting}


\paragraph{}
String is a standard type, so is designed and implemented prior to the definition of the custom interface `LengthValue', and therefore it would be unlikely that standard library developers would foresee the need to implement that (or a similar) interface. However, structural typing allows the cast from `String\&' to `LengthValue\&' to be made because the types are in fact compatible.

\paragraph{}
As mentioned briefly previously, this functionality works equivalently well with primitive types:

\begin{lstlisting}
interface AbsInteger{
	int abs() const;
}

void f(const AbsInteger& value){
	if(value.abs() > 0){
		//...
	}
}

void function(){
	int value = 42;
	f(value);
}
\end{lstlisting}

\paragraph{}
The Implementation section discusses how this feature is implemented efficiently, in particular detailing how the performance of calling interface methods has a negligible overhead compared to existing virtual method calls in languages such as C++.

\clearpage

\subsection{New Operator}

\paragraph{}
Like C++, Loci provides the new operator, although the syntax and semantics are slightly different.


\begin{lstlisting}
class Type(int a){ }

Type f(){
	return Type(5);
}

void function(){
	// Stack and heap allocations, like in C++.
	Type stackAllocated = Type(0);
	Type * heapAllocated = new<raw> Type(0);
	
	// Allocates space on heap, and moves return
	// value of function 'f' from stack to heap.
	Type * heapMoved = new<raw> f();
	
	// Raw allocations must be deallocated.
	delete<raw> heapAllocated;
	delete<raw> heapMoved;
}
\end{lstlisting}


\paragraph{}
In particular, C++ forces the new operator to call a type constructor, so that stack objects are moved to the heap by a copy constructor. Loci, however, makes it easy to move objects without running any code (other than memcpy), and therefore the new operator was redesigned to be applied to any R-value (the details of which are described later) of the desired type, and will move that value onto the heap.

\paragraph{}
The new operator also requires the name of the memory management method to be used, which in the sample code above is `raw', meaning that the developer is responsible for calling delete on the pointers when finished with them (i.e. exactly like C++).

\clearpage

\subsubsection{Memory Management Methods}

\paragraph{}
The previous sample code showed `raw' allocations, in which allocation and construction of objects is performed as in C++. However, Loci supports other forms of allocation\footnote{And it is recommended for developers to avoid raw allocations as much as possible.}:


\begin{lstlisting}
void function(){
	// Automatically freed when leaving scope,
	// but only one instance can exist.
	UPtr<Type> uniquePtr = new<unique> Type(0);
	
	// Above is just syntactic sugar for...
	UPtr<Type> uniquePtr1 = UPtr<Type>(new<raw> Type(0));
	
	// Invalid - cannot copy unique pointers.
	UPtr<Type> uniquePtr2 = uniquePtr;
	
	// Allocated via garbage collection.
	Type * gcPtr = new<gc> Type(0);
	
	// Reference counted.
	RCPtr<Type> refCountedPtr = new<refcount> Type(0);
	
	// Can be copied, increasing ref count.
	RCPtr<Type> refCountedPtr1 = refCountedPtr;
	
	// Shared; could be GC or referencing counting.
	SPtr<Type> sharedPtr = new<shared> Type(0);
	
	// Can be copied.
	SPtr<Type> sharedPtr1 = sharedPtr;
	
	// Invalid - there is no default.
	auto defaultPtr = new Type(0);
}
\end{lstlisting}


\paragraph{}
Design decisions for new memory management methods were made in consideration of the fundamental aim to minimise the syntax required to instantiate an object on the heap, while maximising the available options for how to manage the memory. As the sample code shows, there is no default allocation method. The design perspective is that the lack of a default forces the programmer to consider how objects are to be allocated.

\paragraph{}
In contract, C++ chooses to use a raw allocation as the basis of the new operator, however this is generally the most dangerous choice because exceptions can cause a delete statement to be missed and therefore memory is leaked; the other memory management methods are much safer.

\paragraph{}
Different memory management methods return different types that are responsible for managing the constraints of that allocation method. `UPtr', `RCPtr' and `SPtr' are types declared in the root namespace that are provided in the standard library.

\subsubsection{Unique Allocation}

\paragraph{}
While the other allocation methods are relatively complex, the `unique' method is trivial, and returns an object of type `UPtr', that is very similar to C++'s std::auto\_ptr. The key difference is that Loci provides much stronger rules relating to moving objects, so there are no problems with copying or assigning.

\paragraph{}
The details of moving vs copying is explained in great detail in the `LValues and RValues' section, however the short form description is that while auto\_ptrs have problems when they are copied or assigned\footnote{Since one auto\_ptr must take ownership of the pointer while another loses it, leading to potentially surprising results.}, Loci prevents the problem by disallowing copying (for these cases) and providing moving as a superior alternative.

\paragraph{}
Unique allocation should generally be used as much as possible as long as it doesn't restrict the developer, since it offers no overhead against a `raw' allocation, and yet will reliably recollect the memory and call the destructor.

\subsubsection{Reference Counting}

\paragraph{}
Reference counting provides a simple and deterministic way to release memory and call destructors when there are no remaining references to an object on the heap. Unlike garbage collection, which cannot ensure destructors are called, reference counting means destructors are called as soon as the last referring `RCPtr' instance is destroyed.

\paragraph{}
It does however restrict the developer to passing around `RCPtr' instances that are responsible for incrementing and decrementing the count. Another key limitation of reference counting is the failure to collect cycles; `RCWeakPtr' is provided with the usual `weak' semantics.

\subsubsection{Shared Allocation}

\paragraph{}
`SPtr' is provided to allow code\footnote{The imagined use case here is libraries, that are often dependent on the choices of the program that links them.} to take advantage of GC where it is available, but falls back to reference counting otherwise. This is typically best for immutable structures such as trees, and performance is usually better when using garbage collection.

\paragraph{}
This method of allocation is slightly more limited than using `gc' and does not expose a raw pointer that can be freely copied around the program, since this obviously wouldn't work with reference counting. Another restriction is that types must not have destructors, since GC cannot provide any sort of deterministic destruction. Finally, developers must be careful to avoid cycles.

\paragraph{}
In many ways, therefore, shared allocation suffers from the combined weaknesses of both GC and reference counting. It does, however, allow code that would hope to use garbage collection fall back to reference counting when necessary.

\subsubsection{Garbage Collection}

\paragraph{}
Garbage collection may also be available, using a conservative collector\footnote{Meaning that it doesn't need to move memory, which would be difficult to do at the level of C.}, and this is generally a good choice for allocating POD\footnote{Plain Old Data} types such as vectors, strings, trees etc. The availability of garbage collection depends on the standard library build type, so that some applications can choose to not use garbage collection; in such a case the developer will experience linker errors that will make the problem clear.

\paragraph{}
As with shared allocation, Loci will disallow the allocation of an object via garbage collection if it has a destructor. Finalisers could've been used to trigger destructor execution, but they are \emph{not deterministic}, and therefore any actions within the destructor cannot be guaranteed to be executed at a reasonable time\footnote{Unless other methods such as reference counting are used as well, however this defeats the purpose of garbage collection.}.

\paragraph{}
Typically types which might be garbage collected should not require a destructor, since most destructors are required for managing memory of the type's member variables, something that usually becomes unnecessary in the the presence of garbage collection.\footnote{Note that if a type's member variables have destructors, then the type itself will also have an auto-generated destructor which will call them, prohibiting its use with garbage collection.}

\paragraph{}
However, as with all rules, there may be reasonable exceptions, so a `forcegc' option is provided:


\begin{lstlisting}
class Type(int v){
	~Type(){
		//...
	}
};

void function(){
	// Fails to compile - 'Type' has destructor.
	Type * gcPtr = new<gc> Type(0);
	
	// Succeeds - but probably isn't wise, since 
	// the destructor will never be called.
	Type * gcPtr1 = new<forcegc> Type(0);
}
\end{lstlisting}


\clearpage

\subsection{L-values and R-values}

\paragraph{}
Loci uses the concept of L-values and R-values to provide a very simple way to implement move semantics. C++ supports copying as the primary operation for replicating values, however Loci instead uses move semantics by default. The latest version of C++ adds support for move operations, however this must be implemented on a per-type basis; Loci has no such complexities.

\paragraph{}
What this means for the programmer is that it is possible to easily prevent copies of class-types, because they are not copyable by default. There are many examples where such behaviour is desirable, including unique smart pointer types, socket types, mutex types, stream types etc.

\paragraph{}
L-values can be considered as actual storage locations, on either the heap or the stack. On the other hand, R-values are values `in-transit' and can be captured into an L-value. For example some variable `v' is an L-value, whereas the expression `v + 1' is an R-value.

\paragraph{}
This section also discusses `nullable objects', which have particularly expressive move semantics.

\paragraph{}
Here's an example of the move semantics in Loci:

\begin{lstlisting}
class SomeType(int * p){
	~SomeType(){
		// This destructor is only run
		// if the object is non-empty.
		delete<raw> @p;
	}
}

SomeType f(){
	// Return r-value.
	return SomeType(new<raw> 1);
}

SomeType function(){
	// Constructor called, and value moved into stack.
	// (Would be optimised to in-place construction on the stack.)
	SomeType a = SomeType(new<raw> 2);
	
	// Nullable type.
	SomeType? b = SomeType(new<raw> 3);
	
	// Existing value in 'a' destroyed (destructor called),
	// value in 'b' moved into 'a', and 'b' is now left empty.
	a = extract b;
	
	// Again, the value in 'a' is destroyed, and replaced
	// with the r-value result of calling function 'f'.
	a = f();
	
	// Invalid - 'a' does not have a nullable type.
	cast<void>(extract a);
	
	// This will (typically) trigger an exception,
	// since the variable 'b' is empty.
	b.method();
	
	// R-Value returned from 'f' moved into empty lvalue 'b',
	// which then becomes non-empty.
	b = f();
	
	// This is only allowed if the compiler can statically
	// determine that the lvalue 'a' is being destroyed as
	// this point, and therefore can legitimately be cast
	// to an rvalue and returned instead.
	return a;
}
\end{lstlisting}


\subsubsection{Nullable Types}

\paragraph{}
Loci has built-in support for `nullable' types, denoted by a question mark following the type name, which can be set to null, or compared with null, and also filled with non-null values of that type. Null objects can also be obtained by giving a nullable L-value a non-null value, and then extracting that value (with `extract').

\paragraph{}
The results of calling a method on a null object or casting it to a non-nullable type are defined to be throwing an exception of type `EmptyObjectException', but compilers are also allowed (and encouraged) to detect errors of this kind statically if possible and hence produce compile-time errors.

\paragraph{}
`extract' is the extraction operator, which causes the value within a nullable L-value to be extracted, turning it into a (nullable) R-value, and making the L-value empty. Extracting a nullable L-value that already has a null value is valid, and simply produces a null R-value\footnote{Therefore, extracted R-values are of `nullable' type themselves.}. For example:

\begin{lstlisting}
void f(){
	ObjectType? a = null;
	ObjectType? b = extract a;
	
	assert(a == null);
	assert(b == null);
}
\end{lstlisting}

\paragraph{}
Note that if an R-value is not captured into an L-value then it will be destroyed at the end of the statement, so extract can be used to destroy the value in a nullable L-value.

\paragraph{}
There is also the assignment statement of the form `v = expr;', in which the current value in L-value `v' is destroyed, and the R-value `expr' is moved into `v'. However, if there is no value currently in the lvalue prior to the assignment, then the destructor will not be called, as developers would expect.

\paragraph{}
Nullable types are built-in for a number of reasons, but most significantly because they depend on providing special behaviour the assignment statement. Unlike C++, Loci does not provide operator overloading for assignment, since the assignment operation behaviour is auto-generated outside of the object, and developers should find this behaviour much easier to handle.

\subsubsection{Non-nullable Types}

\paragraph{}
Without resorting to unsafe operators, non-nullable objects are considerably more limited than nullable objects. One limitation is that the extraction operator cannot be applied to non-nullable types, since doing so would put the objects in a undefined state and `extract' is a safe operator (unsafe operators are described later). Furthermore, non-nullable objects cannot be set or compared with null.

\paragraph{}
For this loss of functionality there is, however, a gain in speed since all checks are eliminated, and a reduction in size since nullable objects must have an extra field indicating whether they are null. Also, assignment is valid for non-nullable objects, and will always call the destructor of the L-value (since it cannot be null) and move the R-value into the L-value.

\subsubsection{Compared to C++}

\paragraph{}
This previous code showed the move semantics applied to a type `SomeType', for which the user has specified no special methods. In fact, `SomeType' is almost the complete implementation of `UPtr'\footnote{It is missing a trivial `Default' constructor implementation.}.

\paragraph{}
Additionally, the developer writing the class doesn't need to worry to about objects having a null state, since nullable types provide this, reliably and automatically producing the correct code for assignment and extraction.

\paragraph{}
In contract, the equivalent code in C++ would require manually defining a copy constructor (or a move constructor in the latest version) and an assignment method, which might look similar to the following:

\begin{lstlisting}
// This is C++ code!
class SomeType{
	public:
		SomeType(int * p){
			p_ = p;
		}
		
		SomeType(SomeType& t){
			p_ = t.p_;
			
			// Need to zero out state in previous copy.
			t.p_ = 0;
		}
		
		SomeType& operator=(const SomeType& t){
			// Avoid self-assignment.
			if(&t != this){
				// Destroy existing local state.
				delete p_;
				
				// Copy state.
				p_ = t.p_;
				
				// Zero state in 't'.
				t.p_ = 0;
			}
			return *this;
		}
		
		~SomeType(){
			// Check whether the object is empty.
			if(p_ == 0){
				delete p_;
			}
		}
	
	private:
		int * p_;
	
};
\end{lstlisting}


\paragraph{}
Clearly, C++ requires a large amount of code to produce similar semantics; Loci generates this code on behalf of the user, saving the programmer time in terms of both development and testing.

\clearpage

\subsection{Unsafe Move Operators}

\paragraph{}
The previous section discusses how to safely move objects.

\paragraph{}
TODO

\clearpage

\subsection{Vector Types}

\paragraph{}
Loci supports SIMD operations directly through the use of vector types, allowing operations such as addition to be applied in parallel to a vector of integer or floating point values.


\begin{lstlisting}
void function(){
	int!4 a = {0, 1, 2, 3};
	int!4 b = {5, 6, 7, 8};
	int!4 c = a + b;
	
	// The resulting values.
	assert(c[0] == 5);
	assert(c[1] == 7);
	assert(c[2] == 9);
	assert(c[3] == 11);
}
\end{lstlisting}


\paragraph{}
The ternary operator also provides some interesting behaviour for vectorised types:


\begin{lstlisting}
void function(){
	int!4 a = {0, 1, 2, 3};
	int!4 b = {4, 5, 6, 7};
	bool!4 c = {true, false, true, false}
	
	int!4 d = c ? a : b;
	
	// The resulting values.
	assert(d[0] == 0);
	assert(d[1] == 5);
	assert(d[2] == 2);
	assert(d[3] == 7);
}
\end{lstlisting}

\clearpage

\subsection{Algebraic Datatypes}

\paragraph{}
Functional languages such as ML and Haskell provide algebraic data types as a mechanism for holding information, which may itself be of a number of different types. The following is a clear example of such a case, implemented in Loci:


\begin{lstlisting}
datatype BinaryTree{
	Leaf(int v){
		String toString(){
			return "Leaf(" + @v.toString() + ")";
		}
	}
	
	Node(BinaryTree& left, BinaryTree& right){
		String toString(){
			return "Node(" + @left.toString() +
				", " + @right.toString() + ")";
		}
	}
};
\end{lstlisting}


\paragraph{}
In this case, a binary tree element is either a Leaf which contains only an integer value, or a Node that contains two trees as its left and right children.

\paragraph{}
It is common to need to describe such types when handling lots of data (for example, building ASTs in a compiler), and also in general programming. Expressing similar structures in C or C++ requires the combination of enums, unions and structs, and furthermore unions and class types interact poorly in C++, as they do in Loci:

\begin{lstlisting}
// This is C++ code.

// Invalid - compiler can't know whether
// to call destructor for std::string.
// In Loci the problem is exactly the
// same, so objects cannot be in unions.
union UnionType{
	int i;
	std::string s;
};
\end{lstlisting}

\paragraph{}
Defining the structure isn't useful alone, and Loci expands on the existing `switch' statement to allow accessing and handling the contents of a data type.


\begin{lstlisting}
int getLeftMostValue(const BinaryTree& tree){
	switch(tree){
		case Leaf(int v){
			return v;
		}
		case Node(BinaryTree& left, _){
			return getLeftMostValue(left);
		}
	}
}
\end{lstlisting}

\paragraph{}
Note that the underscore character indicates an unused field of the data type.

\paragraph{}
This statement has some specific semantics:

\begin{enumerate}
\item The sub-types (in this case, `Leaf' and `Node') in the switch statement must be the complete set of sub-types within the parent type (`BinaryTree'); if any types are missed, compilation fails. However unspecified sub-types can be handled using a `default' entry.
\item Case statements can capture L-values within the data types. In the example the value in the leaf is captured so it can be printed to the command line.
\item No `break' statement is required to exit the switch, since this is almost always the desired behaviour and therefore requiring it is tedious for the programmer\footnote{Also, the behaviour is unintuitive for developers who are new to C-style languages.}. However, `continue' can be used to provide the behaviour of moving to the next case if desired.
\end{enumerate}

\clearpage

\subsection{Pattern Matching}

\paragraph{}
Algebraic datatypes are clearly a concept that has been adopted from functional languages such as ML and Haskell. Additionally, Loci supports extracting the members of these data types by binding them through pattern matching:

\begin{lstlisting}
data Pair(int l, int r);

Pair f(){
	return Pair(1, 2);
}

void g(){
	Pair(a, b) = f();
	//...
}
\end{lstlisting}

\paragraph{}
In this example, the types of binding variables `a' and `b' are not required, and are internally set to `auto' by the compiler, so it will then infer them.

\clearpage

\subsection{Operator Overloading}

\paragraph{}
Loci supports operator overloading as a useful way to provide a clean syntax for manipulating standard library or user defined types such as strings, vectors, matrices and arrays. Unlike C++, Loci uses normal function names to define methods that can be used in operator overloading:


\begin{lstlisting}
interface A{
	int compare(const A&) const;
	A add(const A&) const;
	A substract(const A&) const;
};

interface IntArray{
	int indexGet(size_t index);
	void indexSet(size_t index, int value);
};

void function(const A& a0, const A& a1, IntArray& array){
	// All following pairs are equivalent...
	bool compare = a0.compare(a1) < 0;
	bool compare = a0 < a1;
	
	A a2 = a0.opPlus(a1);
	A a2 = a0 + a1;
	
	A a3 = a0.opMinus(a1);
	A a3 = a0 - a1;
	
	array.indexSet(0, 5);
	array[0] = 5;
	
	int i = array.indexGet(0);
	int i = array[0];
}
\end{lstlisting}

\paragraph{}
Of particular interest is the `compare' method, which is an alternative to defining each of the comparison operators individually. Instead, developers just implement this single method which uses a negative, zero or positive integer to indicate (respectively) whether the left value is less than, equal to, or greater than the right value.

\paragraph{}
This functionality can avoid double comparisons (i.e. two applications of the less-than operator with left and right values swapped) inside container types (and other relevant functions/types), which is particularly beneficial for objects that may be expensive to compare, such as strings.

\clearpage

\subsection{Named Parameters}

\paragraph{}
There are often cases where it is difficult to ascertain the purpose of parameters passed to a function, or where it is difficult to remember the order of parameters to a function. For example:


\begin{lstlisting}
void function1(Renderer& renderer, Circle& circle){
	circle.draw(renderer, true);
}
\end{lstlisting}


\paragraph{}
In this case, the meaning of the second argument to the method, `true', is unclear. Similarly in the following case it is difficult to identify the order of parameters:


\begin{lstlisting}
void function2(){
	String haystack = "Hello world!";
	String needle = "world";
	
	// Is it...
	bool found = canFindString(needle, haystack);
	
	// Or...
	bool found = canFindString(haystack, needle);
}
\end{lstlisting}


\paragraph{}
Named parameters are a feature that aims to assist code documentation, as well as calling functions by the names of their parameters rather than the order, which in some cases is more meaningful. The two examples above can therefore be expressed clearly with this feature:


\begin{lstlisting}
void function1(Renderer& renderer, Circle& circle){
	circle.draw(renderer: renderer, drawOutline: true);
}

void function2(){
	bool found = canFindString(needle: "world", haystack: "Hello world!");
}
\end{lstlisting}


\paragraph{}
This is facilitated by the ability to type named function pointers, which can be implicitly cast to ordered function pointers:


\begin{lstlisting}
void f(int first, int second);

void function(){
	*(int)(int first, int second) namedFunctionPtr = f;
	*(int)(int, int) functionPtr = namedFunctionPtr;
	
	namedFunctionPtr(second: 1, first: 0);
	functionPtr(0, 1);
}
\end{lstlisting}


\clearpage

\subsection{Exceptions}

\paragraph{}
There has been (and is continuing to be) much debate on the relative merits of `checked' exceptions, `unchecked' exceptions and C-style error checking (along with other variants).

\paragraph{}
Based on an assessment of the implementations of exceptions in languages such as Java (checked), and C++ and C\# (unchecked), Loci uses unchecked exceptions as a standard method for functions to report some form of failure, since these trigger fewer architectural maintenance problems\footnote{Also, greater compatibility with C, since no extra information must be added to functions.}.


\begin{lstlisting}
interface AbstractException{
	std::string what() const;
}

class RealException(std::string what, int i){
	static Default(std::string what, int i){
		return @(what, i);
	}

	std::string what() const{
		return @what;
	}
}

void f(int i){
	if(i < 0){
		throw RealException("Function 'f' passed negative value.", i);
	}
}

String caller(){
	try{
		f(-1);
	}catch(const AbstractException& exception){
		std::string reason = exception.what();
		//...
	}
}
\end{lstlisting}


\paragraph{}
A stack trace is also constructed while these exceptions are in flight, and in the case that the exception reaches the top level of the program (i.e. the main function), the stack trace is printed along with the contents of the exception type.

\clearpage

\subsection{RTTI}

\paragraph{}
Loci provides far more comprehensive run-time type information than C++, giving extra functionality as well as efficiency to developers.

\subsubsection{is\_a}

\paragraph{}
This supports checking whether the actual type (which is known only at run-time, unless A is a class type) of a reference or pointer conforms to a given target type (B in this example).

\begin{lstlisting}
void f(A& object){
	if(is_a<B&>(object)){
		//...
	}
}
\end{lstlisting}

\paragraph{}
The performance for each case (depending on types of A and B) is:

\begin{itemize}
\item If A is a class type, and B is a class type, then the `is\_a' statement is resolved at compile-time (hence no run-time overhead).
\item If A is a class type, and B is an interface type, then the compiler can again resolve it at compile-time.
\item If A is an interface type, but B is a class type, the implementation for this is just a single comparison, so this is a very efficient way to check the type of an interface reference/pointer.
\item If A is an interface type, and B is an interface type, then this call involves a number of comparisons proportional to the number of methods in the larger interface, unless it can be determined at compile-time that there is a valid static cast from A to B.
\end{itemize}

\subsubsection{dynamic\_cast}

\paragraph{}
This operates just like C++:

\begin{lstlisting}
int f(A& object){
	B& castObject = dynamic_cast<B&>(object);
	return castObject.method();
}
\end{lstlisting}

\paragraph{}
This is effectively just the equivalent of calling is\_a to check the types are compatible, and then either allowing the reference/pointer to A to be treated as a reference/pointer to B, or throwing an exception in the case of a reference type, or returning NULL if it's a pointer.

\subsubsection{typeid}

\paragraph{}
This allows access to information about a type from a reference or pointer to an instance of it:

\begin{lstlisting}
void f(T& a, T& b){
	rtti::type_info typeInfo = typeid(a);
	
	// type_info structures can be compared,
	// but is_a is likely to be more efficient.
	if(typeInfo == typeid(b)){
		//...
	}
	
	// Get the type's name.
	string typeName = typeInfo.name;
	
	// Get the type's virtual table.
	void * vtable = typeInfo.vtable;
	
	// Get the type's size.
	size_t typeSize = typeInfo.size;
	
	for(size_t i = 0; i < typeInfo.methods.size(); i++){
		rtti::method_info methodInfo = typeInfo.methods[i];
		
		// Get method name.
		string methodName = methodInfo.name;
		
		// etc.
	}
}
\end{lstlisting}

\clearpage

\subsection{Faults}

\paragraph{}
Unlike C or C++ (but a lot like Java), Loci converts program errors such as SEGFAULTs into exceptions, to take advantage of the ability to catch exceptions and produce stack traces.


\begin{lstlisting}
int f(int * i){
	return *i;
}

int g(int[4] v, int i){
	return v[i];
}

void h(int v){
	assert(v >= 0);
}

void caller(){
	try{
		int i = f(null);
	}catch(NullPointerException e){
		//...
	}
	
	try{
		int[4] v = int[]{0, 1, 2, 3};
		int i = g(v, 100);
	}catch(VectorIndexOutOfBoundsException e){
		//...
	}
	
	try{
		h(-1);
	}catch(AssertionFailedException e){
		//...
	}
}
\end{lstlisting}


\clearpage

\subsection{Templates}

\paragraph{}
Loci implements templates, to provide parametric polymorphism, which is useful for defining the types of collections (along with many other things). The syntax is slightly simpler than C++:

\begin{lstlisting}
template <T>
class Class(T v){ }
\end{lstlisting}


\subsubsection{Type Properties}

\paragraph{}
Loci allows type properties to be expressed through the use of interfaces. For example:


\begin{lstlisting}
template <T>
interface Comparable{
	ConstructFromInt(int i);

	int compare(const T& v) const;
}

template <T: Comparable<T>>
class Class(T v0, T v1){
	static Default(T v0, T v1){
		return @(v0, v1);
	}

	bool lessThan() const{
		return @v0 < @v1;
	}
};
\end{lstlisting}


\paragraph{}
The interface, which is itself templated, requires that the parameter type `T' to class `Class' has the constructor and comparison operator specified. Note that constructors specified in interfaces can only be used in the context of template type parameters; it is meaningless\footnote{And will cause a compile-time error.} to attempt to construct an interface itself outside of a template.

\paragraph{}
Since primitive types are modelled as objects, even with their implementation being identical to C, they can also be used as template parameters:


\begin{lstlisting}
void function(){
	Class<int> cInt(1, 2);
	assert(cInt.lessThan());
}
\end{lstlisting}


\subsubsection{Instances}

\paragraph{}
The above code shows the creation of a class that has a type parameter `T'. In C++, instances of this class would be generated by the compiler for each type given as type `T'. So the following C++ code would generate four different classes in the object code produced by the compiler:


\begin{lstlisting}
Class<int> cInt;
Class<float> cFloat;

struct StructType{ int a; float b; };
Class<StructType> cS;

Class<StructType *> cSPtr;
\end{lstlisting}


\paragraph{}
In Loci the compiler only creates one instance of the class, which works correctly for all possible types for T. However this requires something similar to auto-boxing\footnote{Without the need to perform a heap allocation.} for primitive types, which is potentially slow, so it's possible to instruct the compiler to create particular instances of a templated class or function, using code such as the following\footnote{Which is essentially identical to the C++ syntax for explicit instantiation.}:


\begin{lstlisting}
template class Class<int>;
template class Class<float>;

struct StructType{ int a; float b; };
template class Class<StructType>;

template class Class<StructType *>;
\end{lstlisting}


\paragraph{}
This then creates the generic version of the class by default, but if the type is int, float, StructType or StructType*, the corresponding specialised (and therefore presumably faster) type is used. There's also a lot of capacity implementation-wise for compilers to improve the performance without breaking the functionality.

\clearpage

\subsection{Namespace Versions}

\paragraph{}
One of the primary goals of Loci is to be an excellent language for providing and using APIs, by ensuring that generated code is compatible across platforms and compilers (or if it is not compatible, fails with a clear error as early as possible).

\paragraph{}
Namespace versions are a fairly novel feature in Loci that aim to make it easy for developers to release multiple versions of their API, and to eliminate old versions and produce clear error messages for code that is still using now unavailable APIs.

\paragraph{}
For example, a library may change its method names, which would give errors indicating to the user of the library that they are calling a non-existent method. Ideally, though, the compiler (or linker) could produce an error indicating that the user of the library is using a non-existent API version, or even better, an outdated version.

\paragraph{}
Furthermore, there are other issues with contending versions of libraries, such as changes to internal implementations. Consider, for example, that a program `P' depends on a library `L'. Both P and L also depend on a library `S'.

\paragraph{}
If P and L use different versions of S (most likely in different shared libraries), they must not pass instances of classes from S between each other, in case the wrong methods are run on a particular instance. Even worse, one version of S may override the other in the dynamic symbol table.

\paragraph{}
Namespace versions offer a solution to these problems:

\begin{lstlisting}
namespace Library{
	class ObjectType{ };
}

namespace Library[a_version_string_100]{
	class ObjectType{ };
}
\end{lstlisting}

\paragraph{}
The first namespace declaration has an implicit version of the empty string, whereas the second has the explicit version ``a\_version\_string\_100". Client code can then use specific versions like so:

\begin{lstlisting}
Library::ObjectType f();

Library[a_version_string_100]::ObjectType g();
\end{lstlisting}

\paragraph{}
But this is slightly awkward, so a version other than the empty string can be selected to be default within a single module for a particular namespace:

\begin{lstlisting}
using Library[a_version_string_100]

// Now the empty string version has to be explicit.
Library[]::ObjectType f();

// Now equivalent to 'Library[a_version_string_100]::ObjectType g();'.
Library::ObjectType g();
\end{lstlisting}

\paragraph{}
The names of symbols within namespaces with different versions are clearly transformed/mangled to differ from each other, ensuring that multiple versions can co-exist.

\paragraph{}
Versions can also be removed:

\begin{lstlisting}
namespace Library[old_version] = null;
\end{lstlisting}

\paragraph{}
In this case, clients of the library will be informed that the version ``old\_version" has been removed.

\clearpage

\section{Standard Library}

\paragraph{}
In addition to the core language syntax and semantics, an important part of the overall system is the standard library, of which some parts are explained here.

\subsection{Strings}

\paragraph{}
Strings are used in Loci as the default way to handle character sequences, mostly replacing the `char *' string type as used in C and C++.

\subsubsection{Literals}

\paragraph{}
Loci breaks away from C by making string literals be of type `string', rather than type `const char *'. However C string literals can be declared by simply prefixing the double quotes with `C':


\begin{lstlisting}
void f(const char * cString){
	printf("%s", cString);
}

void function(){
	// Invalid - no implicit cast from String to char *.
	f("Hello world!");
	
	// Valid - literal prefixed with 'C' gives C string.
	f(C"Hello world!");
}
\end{lstlisting}


\subsubsection{I/O}

\paragraph{}
Input and output operations, such as that provided by C's \emph{printf} function, or by the stream types and shift operators in C++, are achieved in Loci by converting types to string format. Furthermore the language automatically generates methods for data types that convert them to a string, which contains the type's name and the string equivalents of its member variables.

\paragraph{}
Hence printing data is simple:

\begin{lstlisting}
data TwoInts(int a, int b);

void function(){
	auto t = TwoInts(1, 2);
	StdOut().writeLine("{%0}, {%1}, {%2}".format({1.0, "str", t}));
}
\end{lstlisting}

\paragraph{}
This prints:

\begin{verbatim}
1.0, str, TwoInts(1, 2)
\end{verbatim}

\subsection{Tuples}

\paragraph{}
Tuples are a useful way of passing around multiple values of different types together, particularly in the case of returning multiple values.

\begin{lstlisting}
(bool, int, float) f(){
	return (true, 1, 1.5);
}

void function(){
	(a, b, c) = f();
	//...
}
\end{lstlisting}

\paragraph{}
This example shows the creation of a 3-tuple, returning it from a function, and then retrieving the values within it by pattern matching on the type, so that variables `a', `b' and `c' are bound to the values in the tuple.

\subsection{Initializer Lists}

\paragraph{}


\cleardoublepage

\chapter{Implementation}

\paragraph{}
This section discusses the implementations of the features explained above; each feature was designed and considered on the basis on the ease and efficiency of its implementation.

\section{Empty Objects}

\paragraph{}
Empty objects have a very simple implementation: the vtable pointer at the beginning of the object is null (= 0). Code is autogenerated at the caller side of method calls to check that the pointer is not null, and throws an exception otherwise.

\paragraph{}
Creating these checks on the caller side rather than the callee side allows such checks to be optimised out if the object can be guaranteed to be non-empty. Caller-side checks are also required in the case of virtual function calls.

\section{Class Parameters}

\paragraph{}


\section{Virtual Method Calls}

\paragraph{}
The class vtable contains 8 function pointers to 

\cleardoublepage

\chapter{Justification}

\section{Class Inheritance}

\paragraph{}
Loci doesn't support inheritance between classes, in which one class `B' inherits the member variables and methods from another class `A', and usually instances of B can be cast to A (generally via a pointer or reference). Note that the latter functionality is polymorphism, and is supported by Loci's interfaces.

\paragraph{}
C++ supports both single inheritance and multiple inheritance, and even virtual inheritance for resolving the diamond problem. Most other languages, including Java, C\# and D, support only single inheritance, which helps to alleviate the problems with multiple inheritance.

\paragraph{}
However Loci doesn't support inheritance, as a matter of design, instead providing composition as superior method of code reuse. Inheritance has a number of flaws, including the fragile superclass problem, violating encapsulation, increasing coupling between classes and early binding of the implementation of the subclass to that of the superclass.

\paragraph{}
On the other hand, composition is a very powerful mechanism to allow one class to use the functionality of another without relying on the internal implementation of the superclass.

\paragraph{}
While inheritance (in particular tall class hierarchies) encourage monolothic design, a combination of composition and interfaces facilitates modular designs consisting of many small single-purpose classes. Furthermore, classes can modify their internal behaviour, while maintaining a stable API, without breaking code that uses them, which clearly goes a long way towards satisfying Loci's key design goals.

\paragraph{}
The decision not to include inheritance was not made based on whether developers might or might not misuse it\footnote{For example, Java decided to throw out operator overloading on this basis, which turned out to be harmful to those developers who understood how to use the feature correctly.}, but rather the impact it has on the language, both in terms of the semantics and the actual implementation.

\paragraph{}
Any feature added must be integrated into the language, so that it is defined how it interacts with other parts of the language, and may imply a significant amount of effort on the part of the implementor(s).

\cleardoublepage

\chapter{Additional Topics}

\section{Concurrency and Parallelism}

\paragraph{}
Recently there have been many discussions about taking advantage of the increasing amounts of parallelism that is becoming possible through improvements to hardware. Much focus is directed towards programming languages and how they might facilitate taking advantage of these improvements.

\paragraph{}
In particular, a compiler can struggle to optimise normal code in a language such as in C into machine code that can be effectively parallelised by the hardware. Vector types and operations, supported in Loci and explained above, are a good method to achieve performance benefits from new architectures within the context of a single processor.

\paragraph{}
However, there is of course no silver bullet to achieving multi-processor performance benefits; developers must still be responsible for profiling their own code and restructuring it so that it can be run in parallel.

\paragraph{}
Typically, gains are made either in low-level routines (e.g. image processing) via parallelising instructions, or via high-level restructuring. In the former case, the language provides vector operations that need to be used correctly; in the latter it is up to the developer to implement their high-level design.

\paragraph{}
Some forms of parallelism, such as threads, can be dangerous since it is difficult for the programmer to analyse how parallel threads might interact. Processes, on the other hand, are an excellent way to achieve parallelism since memory is no longer shared, but may suffer from a lack of system support or high IPC overhead.

\paragraph{}
Again, it is up to the developer to make and implement these decisions, so like any other language Loci cannot provide significant `automatic' parallelisation of code without substantial cooperation from the developer of the code.

\section{Classes vs Algebraic Datatypes}

\paragraph{}


\section{Garbage Collection}

\paragraph{}
Many languages now include garbage collection, including high-level scripting languages such as Python as well as slightly lower-level languages such as Java and C\#. C and C++ have not adopted garbage collection as a core language feature, focusing instead on manual memory management and smart pointers; D is a very low-level language that does include garbage collection.

\paragraph{}
Loci combines garbage collection with the memory management approaches taken by C++, so that developers can choose the allocation method that is appropriate to their application. The aim is to make it possible to use manual memory management, smart pointers and deterministic destruction alongside garbage collected data.

\paragraph{}
Again, this is divided between `system' modules and PODs, in which modules benefit greatly from stack allocation or heap allocation with management by smart pointers, whereas PODs benefit from being collected automatically.

\paragraph{}
In the case of module objects, it is typical to only have a single non-copyable instance of the object, which needs deterministic destruction so it can release its non-memory resources, and therefore tends to be ideally suited to being placed on the stack.

\paragraph{}
If a module object is allocation on the heap, a unique smart pointer (i.e. where there is one owner) is almost always desired to manage it. If there need to be multiple owners, a reference counted smart pointer can be used.

\paragraph{}
PODs on the other hand are typically immutable (or at least, rarely modified) and certainly copyable objects, but for which it is ideal to avoid copying. If these objects are allocated on the heap, it can be difficult to manage them because many objects simultaneously own them. Garbage collection is the ideal solution in this case.

\paragraph{}
A good example of effective use of garbage collection are ropes used in the implementation of Loci's strings. These are binary trees, of which the nodes are concatenations of their children, and the leaves refer to positions within blocks.

\paragraph{}
Pointers to the nodes, the leaves and the blocks they refer to can be freely copied, eliminating the performance cost of copying, with the knowledge that the garbage collector will reclaim the memory when necessary. Ropes thereby achieve logarithmic complexity (as opposed to linear) for concatenation, insertion and deletion of strings.

\paragraph{}
This can be achieved by reference counting, but the increments and decrements to the counters are costly compared to the simple pointer copies allowed by garbage collection.

\end{document}













