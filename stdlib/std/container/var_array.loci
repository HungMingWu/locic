/**
 * \brief Resizable array.
 */
template <typename T>
class var_array(size_t size, size_t capacity, T* data) {
	static create() {
		return @(0, 0, null);
	}
	
	~ {
		// TODO
	}
	
	void reserve(size_t size) {
		if (size <= @capacity) return;
		T* newData = reinterpret_cast<void*, T*>(calloc(size, sizeof(T)));
		for (auto i: counter<size_t>(0, @size)) {
			newData[i].__assign(@data[i].__extract());
		}
		free(reinterpret_cast<T*, void*>(@data));
		@data = newData;
		@capacity = size;
	}
	
	size_t capacity() const {
		return @capacity;
	}
	
	void resize(size_t size) {
		reserve(size);
		for (auto i: counter<size_t>(size, @size)) {
			@data[i].__clear();
		}
		@size = size;
	}
	
	size_t size() const {
		return @size;
	}
	
	lval<T> ptr_lval<T> indexAt(size_t index) const {
		assert(index < @size);
		return @data[index];
	}
	
	var_array<T> copy() const <T: copyable<T>> {
		auto array = var_array<T>();
		array.resize(@size);
		for (auto i: counter<size_t>(0, @size)) {
			array[i].__assign(self[i].copy());
		}
		return array;
	}
	
}


