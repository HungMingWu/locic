export std.container 0.1.0 {
	
	namespace std {
	
		/**
		 * \brief Resizable array.
		 */
		template <typename T>
		class varray(size_t size, size_t capacity, T* data) {
			static create() noexcept {
				return @(0u, 0u, null);
			}
			
			~ {
				for (auto i: reverse_counter<size_t>(1u, @size, 0u)) {
					nolval(@data[i]).__destroy_value();
				}
				
				free(reinterpret_cast<T*, void*>(@data));
			}
			
			void reserve(size_t size) {
				if (size <= @capacity) {
					return;
				}
				
				T* newData = reinterpret_cast<void*, T*>(alloc(size * sizeof(T)));
				
				for (auto i: counter<size_t>(1u, 0u, @size)) {
					nolval(newData[i]).__set_value(nolval(@data[i]).__extract_value());
				}
				
				free(reinterpret_cast<T*, void*>(@data));
				
				@data = newData;
				@capacity = size;
			}
			
			size_t capacity() const noexcept {
				return @capacity;
			}
			
			void resize(size_t size) {
				self.reserve(size);
				if (size < @size) {
					for (auto i: reverse_counter<size_t>(1u, @size, size)) {
						nolval(@data[i]).__destroy_value();
					}
				}
				@size = size;
			}
			
			bool empty() const noexcept {
				return @size == 0u;
			}
			
			const T* const data() const noexcept {
				return @data;
			}
			
			size_t size() const noexcept {
				return @size;
			}
			
			lval<T> ptr_lval<T> index(size_t index) const noexcept {
				assert index < @size;
				return @data[index];
			}
			
			void clear() noexcept {
				for (auto i: reverse_counter<size_t>(1u, @size, 0u)) {
					nolval(@data[i]).__destroy_value();
				}
				@size = 0u;
			}
			
			void push_back(T value) {
				self.reserve(@size + 1u);
				nolval(@data[@size]).__set_value(move value);
				@size = @size + 1u;
			}
			
			void pop_back() noexcept {
				assert !self.empty();
				@size = @size - 1u;
				nolval(@data[@size]).__destroy_value();
			}
			
			/*varray<T> copy() const <T: copyable<T>> {
				auto array = varray<T>();
				array.resize(@size);
				for (auto i: counter<size_t>(1u, 0u, @size)) {
					array[i].__set_value(self[i].copy());
				}
				return array;
			}*/
			
			varray_range<T> range() const noexcept {
				return varray_range<T>(self);
			}
			
		}
		
		template <typename T>
		class varray_range(const varray<T>& array, size_t position) {
			static create(const varray<T>& array) noexcept {
				return @(array, 0u);
			}
			
			varray_range<T> implicitCopy() const noexcept {
				return @(@array, @position);
			}
			
			bool empty() const noexcept {
				return @position == @array.size();
			}
			
			void next() noexcept {
				assert !self.empty();
				@position += 1u;
			}
			
			lval<T> ptr_lval<T> front() const noexcept {
				return @array[@position];
			}
		}
		
	}
	
}

