export std.string 0.1.0 {
	
	namespace std {
		
		class stringbuffer (size_t length, std::varray<ubyte> byteArray) {
			static create() {
				auto byteArray = std::varray<ubyte>();
				byteArray.push_back(0u);
				return @(0u, move byteArray);
			}
			
			bool empty() const noexcept {
				return @length == 0u;
			}
			
			size_t length() const noexcept {
				return @length;
			}
			
			void append(unichar character) {
				@length += 1u;
				
				// Remove null terminator.
				@byteArray.pop_back();
				
				if (character.in_range(0x00u, 0x7Fu)) {
					// ASCII character range.
					@byteArray.push_back(character.raw_value().cast<ubyte>());
				} else if (character.in_range(0x80u, 0x7FFu)) {
					@byteArray.push_back(ubyte_t.leading_ones(2u) | ((character.raw_value() & uint32_t.trailing_ones(11u)) >> 6u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(6u)) >> 0u).cast<ubyte>());
				} else if (character.in_range(0x800u, 0xFFFFu)) {
					@byteArray.push_back(ubyte_t.leading_ones(3u) | ((character.raw_value() & uint32_t.trailing_ones(16u)) >> 12u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(12u)) >> 6u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(6u)) >> 0u).cast<ubyte>());
				} else {
					assert character.in_range(0x10000u, 0x1FFFFFu);
					
					@byteArray.push_back(ubyte_t.leading_ones(4u) | ((character.raw_value() & uint32_t.trailing_ones(21u)) >> 18u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(18u)) >> 12u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(12u)) >> 6u).cast<ubyte>());
					@byteArray.push_back(ubyte_t.leading_ones(1u) | ((character.raw_value() & uint32_t.trailing_ones(6u)) >> 0u).cast<ubyte>());
				}
				
				// Re-add null terminator.
				@byteArray.push_back(0u);
			}
			
			void append_range(forward_range<unichar>& range) {
				for (unichar character: range) {
					self.append(character);
				}
			}
			
			const ubyte* const c_str() const noexcept {
				return @byteArray.data();
			}
			
			string str() const {
				return string::cstring(self.c_str());
			}
		}
		
	}
	
}

